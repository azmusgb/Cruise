<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
<meta name="theme-color" content="#0a2e4a" />
<title>Deck Explorer · Adventure of the Seas</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Plus+Jakarta+Sans:wght@800;900&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>

<style>
:root{
  --bg:#071a2c;
  --navy:#0a2e4a;
  --glass: rgba(255,255,255,.08);
  --glass2: rgba(255,255,255,.12);
  --brd: rgba(255,255,255,.16);
  --accent:#00b4e6;
  --gold:#ffd740;
  --r: 22px;
  --ease: cubic-bezier(.22,.61,.36,1);
}

*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%}
body{
  font-family:'Inter',system-ui,-apple-system,sans-serif;
  background:var(--bg);
  color:#fff;
  overflow:hidden;
  -webkit-font-smoothing:antialiased;
  text-rendering:optimizeLegibility;
}
button,input{font:inherit}
a{color:inherit;text-decoration:none}
:focus-visible{outline:3px solid rgba(0,180,230,.55);outline-offset:3px;border-radius:14px}

#ocean{position:fixed;inset:0;z-index:-3}
.sky{
  position:fixed;inset:0;z-index:-2;pointer-events:none;
  background:
    radial-gradient(ellipse at 50% 18%, rgba(0,180,230,.14), transparent 60%),
    radial-gradient(ellipse at 20% 88%, rgba(255,215,64,.10), transparent 55%),
    linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,.68));
}
.vignette{
  position:fixed;inset:0;z-index:-1;pointer-events:none;
  background:
    radial-gradient(ellipse at 50% 20%, rgba(255,255,255,.05), transparent 62%),
    radial-gradient(ellipse at 50% 100%, rgba(0,0,0,.45), transparent 65%);
}

/* Header (mobile-first, compact) */
header{
  position:fixed;left:0;right:0;top:0;
  z-index:1000;
  padding-top: env(safe-area-inset-top);
  background:rgba(10,46,74,.68);
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  border-bottom:1px solid rgba(255,255,255,.10);
}
.header-inner{
  height:56px;
  max-width:1400px;
  margin:0 auto;
  padding:0 .85rem;
  display:flex;
  align-items:center;
  gap:.6rem;
}
.brand{
  display:flex;
  flex-direction:column;
  line-height:1.05;
  min-width: 110px;
}
.brand .t{
  font-family:'Plus Jakarta Sans',sans-serif;
  font-weight:950;
  letter-spacing:.01em;
  font-size:.98rem;
}
.brand .s{
  font-size:.70rem;
  opacity:.62;
  font-weight:850;
}
.spacer{flex:1}

.pill{
  display:inline-flex;
  align-items:center;
  gap:.5rem;
  padding:.44rem .78rem;
  border-radius:999px;
  background:rgba(255,255,255,.10);
  border:1px solid rgba(255,255,255,.16);
  font-weight:900;
  font-size:.78rem;
  white-space:nowrap;
}
.pill i{color:var(--gold)}

.search{
  width:min(52vw, 320px);
  padding:.48rem .82rem;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.18);
  background:rgba(255,255,255,.10);
  color:rgba(255,255,255,.95);
  font-weight:850;
}
.search::placeholder{color:rgba(255,255,255,.52)}
.btn{
  display:inline-flex;align-items:center;gap:.5rem;
  padding:.48rem .78rem;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.16);
  background:rgba(255,255,255,.10);
  color:rgba(255,255,255,.92);
  font-weight:900;
  font-size:.78rem;
}
.btn i{color:var(--gold)}

/* Main layout: immersive viewer */
.main{
  position:absolute;
  left:0;right:0;
  top: calc(56px + env(safe-area-inset-top));
  bottom: calc(78px + env(safe-area-inset-bottom));
  padding:.8rem;
  max-width:1400px;
  margin:0 auto;
}
.viewer{
  position:relative;
  height:100%;
  border-radius:var(--r);
  background:rgba(0,0,0,.14);
  border:1px solid rgba(255,255,255,.14);
  box-shadow: 0 18px 70px rgba(0,0,0,.35);
  overflow:hidden;
  touch-action:none;
}

/* Floating HUD */
.hud{
  position:absolute; top:12px; right:12px;
  display:flex; gap:.55rem;
  z-index:50;
}
.hudbtn{
  width:44px;height:44px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.16);
  background:rgba(10,46,74,.62);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  display:grid;place-items:center;
  cursor:pointer;
}
.hudbtn i{color:var(--gold); font-size:1.05rem}

/* Stage & SVG */
.stage{
  position:absolute; inset:0;
  overflow:hidden;
}
.svgwrap{
  position:absolute; left:0; top:0;
  transform-origin: 0 0;
  will-change: transform;
}
.svgwrap svg{
  display:block;
  max-width:none;
  user-select:none;
  -webkit-user-drag:none;
}

/* Fallback image render */
.fallback{
  position:absolute; inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,.06);
}
.fallback img{
  max-width:100%;
  max-height:100%;
  object-fit:contain;
  user-select:none;
  -webkit-user-drag:none;
}

/* Loader + Error */
.overlay{
  position:absolute; inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  flex-direction:column;
  gap:.65rem;
  background:rgba(0,0,0,.18);
  z-index:40;
}
.overlay.on{display:flex}
.spinner{
  width:30px;height:30px;border-radius:999px;
  border:3px solid rgba(255,255,255,.20);
  border-top-color: rgba(0,180,230,.95);
  animation: spin 1s linear infinite;
}
@keyframes spin{to{transform:rotate(360deg)}}
.overlay .msg{
  font-weight:950;
  opacity:.92;
}
.error{
  position:absolute; inset:0;
  display:none;
  padding:1rem;
  z-index:60;
  background:rgba(0,0,0,.24);
}
.error.on{display:block}
.error-card{
  background:rgba(10,46,74,.78);
  border:1px solid rgba(255,255,255,.16);
  border-radius:18px;
  padding:1rem;
  box-shadow: 0 18px 70px rgba(0,0,0,.45);
}
.error-card h3{
  font-family:'Plus Jakarta Sans',sans-serif;
  font-weight:950;
  font-size:1.05rem;
  margin-bottom:.35rem;
}
.error-card .small{
  opacity:.82;
  font-weight:750;
  line-height:1.45;
  font-size:.88rem;
}
.error-card code{
  display:block;
  margin:.55rem 0;
  padding:.55rem .65rem;
  border-radius:12px;
  background:rgba(0,0,0,.22);
  border:1px solid rgba(255,255,255,.12);
  overflow:auto;
}

/* Highlight overlay */
.rc-hit{ filter: drop-shadow(0 0 10px rgba(255,215,64,.85)); }
.rc-overlay{ pointer-events:none; }

/* Bottom deck rail */
footer{
  position:fixed; left:0; right:0; bottom:0;
  z-index:1000;
  padding-bottom: env(safe-area-inset-bottom);
  background:rgba(10,46,74,.68);
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  border-top:1px solid rgba(255,255,255,.10);
}
.foot-inner{
  height:78px;
  max-width:1400px;
  margin:0 auto;
  padding:0 .85rem;
  display:flex;
  align-items:center;
  gap:.75rem;
}
.status{
  display:flex;align-items:center;gap:.5rem;
  font-weight:900;font-size:.78rem;
  opacity:.86;
  min-width: 96px;
}
.dot{
  width:9px;height:9px;border-radius:999px;
  background: rgba(0,180,230,.95);
  box-shadow: 0 0 0 0 rgba(0,180,230,.35);
  animation: pulse 1.3s ease-out infinite;
}
@keyframes pulse{
  0%{box-shadow:0 0 0 0 rgba(0,180,230,.35)}
  100%{box-shadow:0 0 0 14px rgba(0,180,230,0)}
}
.deckrail{
  flex:1;
  display:flex;
  gap:.45rem;
  overflow:auto;
  padding:.35rem .15rem;
  scroll-snap-type:x mandatory;
  -webkit-overflow-scrolling: touch;
}
.deckrail::-webkit-scrollbar{display:none}
.deckchip{
  flex:0 0 auto;
  scroll-snap-align:center;
  padding:.52rem .85rem;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.08);
  color:rgba(255,255,255,.92);
  font-weight:950;
  font-size:.78rem;
  cursor:pointer;
}
.deckchip.active{
  background: linear-gradient(135deg, rgba(0,180,230,.95), rgba(255,215,64,.92));
  color: rgba(8,28,46,.96);
  border-color: rgba(255,255,255,.18);
}
.footerbtn{
  flex:0 0 auto;
}

/* Toast */
.toast{
  position:fixed;
  left:50%;
  transform:translateX(-50%);
  bottom: calc(96px + env(safe-area-inset-bottom));
  z-index:2000;
  background:rgba(10,46,74,.88);
  border:1px solid rgba(255,255,255,.14);
  padding:.62rem .85rem;
  border-radius:16px;
  box-shadow:0 18px 70px rgba(0,0,0,.45);
  font-weight:950;
  font-size:.82rem;
  opacity:0;
  pointer-events:none;
  transition: opacity .18s var(--ease), transform .18s var(--ease);
}
.toast.on{
  opacity:1;
  transform:translateX(-50%) translateY(-2px);
}

@media (prefers-reduced-motion: reduce){
  *{animation:none !important; transition:none !important}
}
</style>
</head>

<body>
<canvas id="ocean" aria-hidden="true"></canvas>
<div class="sky" aria-hidden="true"></div>
<div class="vignette" aria-hidden="true"></div>

<header>
  <div class="header-inner">
    <div class="brand">
      <div class="t">Deck Explorer</div>
      <div class="s">Zoom · pan · cabin search</div>
    </div>

    <div class="spacer"></div>

    <span class="pill" id="pillDeck"><i class="fas fa-layer-group"></i><span>Deck 06</span></span>
    <input class="search" id="roomSearch" inputmode="numeric" autocomplete="off" spellcheck="false"
           placeholder="Find cabin # (e.g. 6650)" aria-label="Find cabin number">
    <a class="btn" href="index.html" aria-label="Back to dashboard"><i class="fas fa-arrow-left"></i><span class="hide-sm">Dashboard</span></a>
  </div>
</header>

<main class="main">
  <section class="viewer" aria-label="Deck plan viewer">
    <div class="hud" aria-label="Viewer controls">
      <button class="hudbtn" id="btnZoomIn" title="Zoom in" aria-label="Zoom in"><i class="fas fa-plus"></i></button>
      <button class="hudbtn" id="btnZoomOut" title="Zoom out" aria-label="Zoom out"><i class="fas fa-minus"></i></button>
      <button class="hudbtn" id="btnReset" title="Fit to view" aria-label="Fit to view"><i class="fas fa-crosshairs"></i></button>
    </div>

    <div class="stage" id="stage">
      <div class="svgwrap" id="svgWrap" aria-label="SVG deck content"></div>

      <div class="fallback" id="fallback" aria-label="Fallback deck image">
        <img id="fallbackImg" alt="Deck plan (fallback)">
      </div>

      <div class="overlay" id="loading">
        <div class="spinner" aria-hidden="true"></div>
        <div class="msg" id="loadingMsg">Loading deck…</div>
      </div>

      <div class="error" id="error">
        <div class="error-card" id="errorCard"></div>
      </div>
    </div>
  </section>
</main>

<footer>
  <div class="foot-inner">
    <div class="status" id="status"><span class="dot"></span><span>Ready</span></div>
    <div class="deckrail" id="deckRail" aria-label="Deck selector"></div>
    <button class="btn footerbtn" id="btnFamily" type="button"><i class="fas fa-star"></i>Family</button>
  </div>
</footer>

<div class="toast" id="toast" role="status" aria-live="polite"></div>

<script>
(() => {
  'use strict';

  /* =========================
     Deck SVG filenames
     ========================= */
  const DECKS = [2,3,4,5,6,7,8,9,10,11,12,13,14,15].map(n => ({
    n,
    file: `deck-${String(n).padStart(2,'0')}-final.min.svg`
  }));

  // Known cabins (you can extend)
  const FAMILY_CABINS = ['6650','8528','8612','8370','3622'];

  const STORAGE = {
    deck: 'rccl.decks.activeDeck.v4',
    zoom: 'rccl.decks.zoom.v4',
    tx:   'rccl.decks.tx.v4',
    ty:   'rccl.decks.ty.v4',
    base: 'rccl.decks.basePath.v4'
  };

  /* =========================
     DOM
     ========================= */
  const stage = document.getElementById('stage');
  const svgWrap = document.getElementById('svgWrap');
  const fallback = document.getElementById('fallback');
  const fallbackImg = document.getElementById('fallbackImg');

  const pillDeck = document.getElementById('pillDeck');
  const roomSearch = document.getElementById('roomSearch');
  const status = document.getElementById('status');

  const deckRail = document.getElementById('deckRail');

  const btnZoomIn = document.getElementById('btnZoomIn');
  const btnZoomOut = document.getElementById('btnZoomOut');
  const btnReset = document.getElementById('btnReset');
  const btnFamily = document.getElementById('btnFamily');

  const loading = document.getElementById('loading');
  const loadingMsg = document.getElementById('loadingMsg');

  const error = document.getElementById('error');
  const errorCard = document.getElementById('errorCard');

  const toast = document.getElementById('toast');
  const ocean = document.getElementById('ocean');

  if (!stage || !svgWrap || !fallback || !fallbackImg || !pillDeck || !roomSearch || !status ||
      !deckRail || !btnZoomIn || !btnZoomOut || !btnReset || !btnFamily ||
      !loading || !loadingMsg || !error || !errorCard || !toast || !ocean) {
    console.error('[decks] Missing required DOM elements.');
    return;
  }

  /* =========================
     Helpers
     ========================= */
  const clamp = (v,a,b) => Math.max(a, Math.min(b,v));
  const pad2  = (n) => String(n).padStart(2,'0');
  const digits = (s) => String(s||'').replace(/[^\d]/g,'');
  const esc = (s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  let toastTimer = 0;
  function showToast(msg){
    toast.textContent = String(msg||'');
    toast.classList.add('on');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toast.classList.remove('on'), 1400);
  }
  function setStatus(text){
    const span = status.querySelector('span:last-child');
    if (span) span.textContent = String(text||'');
  }
  function showLoading(on, msg){
    loading.classList.toggle('on', !!on);
    if (msg) loadingMsg.textContent = msg;
  }
  function showError(html){
    error.classList.add('on');
    errorCard.innerHTML = html;
  }
  function hideError(){
    error.classList.remove('on');
    errorCard.innerHTML = '';
  }

  /* =========================
     State (pan/zoom)
     ========================= */
  let activeDeck = Number(localStorage.getItem(STORAGE.deck) || 6);
  if (!Number.isFinite(activeDeck)) activeDeck = 6;

  let zoom = Number(localStorage.getItem(STORAGE.zoom) || 1);
  let tx   = Number(localStorage.getItem(STORAGE.tx)   || 0);
  let ty   = Number(localStorage.getItem(STORAGE.ty)   || 0);

  zoom = clamp(zoom, 0.35, 5);

  let currentSVG = null;      // inline SVG ref (for highlight/search)
  let usingFallbackImg = false;

  const pointers = new Map();
  let isDragging = false;
  let lastPan = {x:0,y:0};
  let pinchStart = null;

  function persistView(){
    try{
      localStorage.setItem(STORAGE.deck, String(activeDeck));
      localStorage.setItem(STORAGE.zoom, String(zoom));
      localStorage.setItem(STORAGE.tx, String(tx));
      localStorage.setItem(STORAGE.ty, String(ty));
    }catch{}
  }

  function applyTransform(){
    svgWrap.style.transform = `translate(${tx}px, ${ty}px) scale(${zoom})`;
    persistView();
  }

  /* =========================
     Base path auto-discovery
     ========================= */
  function baseCandidates(){
    // Try previously working base first
    const savedBase = localStorage.getItem(STORAGE.base);
    const list = [];

    if (savedBase) list.push(savedBase);

    // Common layouts:
    // - decks.html next to /decks/
    // - decks.html in /docs/ next to /docs/decks/
    // - decks.html in /pages/ next to /pages/decks/
    // - global /decks/
    // - assets/decks/
    list.push('./decks/');
    list.push('../decks/');
    list.push('../../decks/');
    list.push('../../../decks/');
    list.push('/decks/');

    list.push('./assets/decks/');
    list.push('../assets/decks/');
    list.push('../../assets/decks/');
    list.push('/assets/decks/');

    // De-dupe while preserving order
    const seen = new Set();
    return list.filter(p => (p && !seen.has(p) && seen.add(p)));
  }

  async function fetchText(url){
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.text();
  }

  async function tryResolveDeckUrl(deckFile){
    // Build absolute URL candidates from baseCandidates()
    const bases = baseCandidates();
    const tried = [];

    for (const base of bases){
      const u = new URL(base + deckFile, window.location.href).toString();
      tried.push(u);
      try{
        // Cheap probe: try GET (GitHub Pages supports it; HEAD sometimes is quirky)
        // Also avoid huge wait on slow networks by short delay between attempts.
        const text = await fetchText(u);
        return { ok:true, url:u, text, tried };
      }catch(e){
        // continue
        await sleep(10);
      }
    }
    return { ok:false, tried };
  }

  /* =========================
     SVG handling (inline + fallback img)
     ========================= */
  function clearSvg(){
    svgWrap.innerHTML = '';
    currentSVG = null;
    usingFallbackImg = false;
    fallback.style.display = 'none';
  }

  function ensureViewBox(svg){
    if (!svg.getAttribute('viewBox')){
      const w = parseFloat(svg.getAttribute('width') || '0');
      const h = parseFloat(svg.getAttribute('height') || '0');
      if (w > 0 && h > 0) svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
    }
    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
  }

  function fitToViewport(){
    if (!currentSVG) return;

    const vb = currentSVG.viewBox && currentSVG.viewBox.baseVal;
    const vbW = (vb && vb.width) ? vb.width : 1200;
    const vbH = (vb && vb.height)? vb.height: 700;

    const rect = stage.getBoundingClientRect();
    const availW = Math.max(320, rect.width - 28);
    const availH = Math.max(320, rect.height - 28);

    const s = Math.min(availW / vbW, availH / vbH);
    zoom = clamp(s, 0.35, 2.8);

    tx = (rect.width/2) - (vbW/2) * zoom;
    ty = (rect.height/2) - (vbH/2) * zoom;

    applyTransform();
  }

  function removeOverlay(svg){
    if (!svg) return;
    const old = svg.querySelector('#rc-room-overlay');
    if (old) old.remove();
    svg.querySelectorAll('.rc-hit').forEach(el => el.classList.remove('rc-hit'));
  }

  function ensureOverlay(svg){
    let g = svg.querySelector('#rc-room-overlay');
    if (!g){
      g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.setAttribute('id', 'rc-room-overlay');
      g.setAttribute('class', 'rc-overlay');
      svg.appendChild(g);
    }
    return g;
  }

  function findRoomElements(svg, roomNumber){
    const q = digits(roomNumber);
    if (!q) return [];

    const hits = [];
    svg.querySelectorAll(`[id*="${CSS.escape(q)}"]`).forEach(el => hits.push(el));
    svg.querySelectorAll(`[aria-label*="${CSS.escape(q)}"], [data-room*="${CSS.escape(q)}"]`).forEach(el => hits.push(el));
    svg.querySelectorAll('text, tspan').forEach(el => {
      const t = (el.textContent || '').trim();
      if (t === q) hits.push(el);
    });

    const seen = new Set();
    return hits.filter(el => {
      const key = `${el.tagName}|${el.id||''}|${el.getAttribute('aria-label')||''}|${(el.textContent||'').trim()}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }

  function focusOnBBox(bbox){
    const rect = stage.getBoundingClientRect();
    const targetX = rect.width/2;
    const targetY = rect.height/2;
    const cx = bbox.x + bbox.width/2;
    const cy = bbox.y + bbox.height/2;
    tx = targetX - (cx * zoom);
    ty = targetY - (cy * zoom);
    applyTransform();
  }

  function highlightRoom(roomNumber, {announce=true} = {}){
    const q = digits(roomNumber);
    if (!q) { if (announce) showToast('Enter a cabin number'); return false; }

    if (usingFallbackImg){
      if (announce) showToast('Deck shown (fallback). Highlight needs inline SVG.');
      return false;
    }
    if (!currentSVG){
      if (announce) showToast('Deck not loaded');
      return false;
    }

    removeOverlay(currentSVG);

    const hits = findRoomElements(currentSVG, q);
    if (!hits.length){
      if (announce) showToast(`Cabin ${q} not found here`);
      return false;
    }

    hits.forEach(el => el.classList.add('rc-hit'));

    let bboxTarget = hits[0];
    if (bboxTarget.tagName.toLowerCase() === 'tspan' && bboxTarget.parentElement) bboxTarget = bboxTarget.parentElement;

    let bbox;
    try { bbox = bboxTarget.getBBox(); }
    catch {
      if (announce) showToast(`Cabin ${q} found (can't focus)`);
      return true;
    }

    const g = ensureOverlay(currentSVG);
    const r = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    r.setAttribute('x', String(bbox.x - 12));
    r.setAttribute('y', String(bbox.y - 10));
    r.setAttribute('width', String(bbox.width + 24));
    r.setAttribute('height', String(bbox.height + 20));
    r.setAttribute('rx','10'); r.setAttribute('ry','10');
    r.setAttribute('fill','rgba(255,215,64,0.10)');
    r.setAttribute('stroke','rgba(255,215,64,0.95)');
    r.setAttribute('stroke-width','3');
    r.setAttribute('vector-effect','non-scaling-stroke');
    g.appendChild(r);

    zoom = clamp(Math.max(zoom, 1.05), 0.35, 5);
    focusOnBBox(bbox);

    if (announce) showToast(`Cabin ${q} highlighted`);
    return true;
  }

  function highlightFamilyCabins(){
    if (usingFallbackImg){
      showToast('Fallback view: Family highlight needs inline SVG.');
      return false;
    }
    if (!currentSVG){
      showToast('Deck not loaded');
      return false;
    }

    let first = null;
    let count = 0;
    for (const c of FAMILY_CABINS){
      const hits = findRoomElements(currentSVG, c);
      if (hits.length){
        count++;
        if (!first) first = c;
      }
    }
    if (!count){
      showToast('No family cabins detected on this deck');
      return false;
    }
    highlightRoom(first, {announce:true});
    if (count > 1) showToast(`Found ${count} family cabins here`);
    return true;
  }

  async function loadDeck(deckNum){
    hideError();
    clearSvg();
    setStatus('Loading…');

    activeDeck = deckNum;
    pillDeck.querySelector('span').textContent = `Deck ${pad2(deckNum)}`;
    deckRail.querySelectorAll('.deckchip').forEach(ch => {
      ch.classList.toggle('active', Number(ch.dataset.deck) === deckNum);
    });

    showLoading(true, `Preparing Deck ${pad2(deckNum)}…`);

    const deck = DECKS.find(d => d.n === deckNum);
    if (!deck){
      showLoading(false);
      setStatus('Error');
      showError(`<h3>Deck not available</h3><div class="small">No SVG configured for deck ${esc(deckNum)}.</div>`);
      return;
    }

    const resolved = await tryResolveDeckUrl(deck.file);

    if (!resolved.ok){
      showLoading(false);
      setStatus('Load failed');

      // Also try rendering as <img> with the most likely path (for a visual fallback)
      const fallbackBase = baseCandidates()[0] || './decks/';
      const fallbackUrl = new URL(fallbackBase + deck.file, window.location.href).toString();
      fallbackImg.src = fallbackUrl;
      fallback.style.display = 'flex';
      usingFallbackImg = true;

      showError(`
        <h3>Deck SVG couldn’t be fetched</h3>
        <div class="small">
          This usually means <strong>the SVG path is wrong</strong> on GitHub Pages (folder mismatch).
          <br><br>
          <strong>Tried URLs:</strong>
          ${resolved.tried.slice(0,8).map(u => `<code>${esc(u)}</code>`).join('')}
          ${resolved.tried.length > 8 ? `<div class="small" style="margin-top:.35rem">(+${resolved.tried.length-8} more)</div>` : ``}
          <br>
          <strong>Fix:</strong> ensure <code>decks.html</code> is in the same folder level as <code>decks/</code>,
          or move <code>decks/</code> to where this page expects it.
          <br><br>
          <strong>Tip:</strong> open one directly in Safari:
          <code>${esc(resolved.tried[0] || '...')}</code>
          If it 404s, that’s the root cause.
        </div>
      `);
      showToast('SVG path mismatch');
      return;
    }

    // Cache base path that worked
    try{
      const urlObj = new URL(resolved.url);
      const base = resolved.url.replace(deck.file, '');
      localStorage.setItem(STORAGE.base, base);
    }catch{}

    // Inline SVG
    svgWrap.innerHTML = resolved.text;
    const svg = svgWrap.querySelector('svg');
    if (!svg){
      showLoading(false);
      setStatus('Error');
      showError(`<h3>Invalid SVG file</h3><div class="small">Fetched content did not contain an <code>&lt;svg&gt;</code> element.</div>`);
      return;
    }

    currentSVG = svg;
    usingFallbackImg = false;
    fallback.style.display = 'none';

    ensureViewBox(svg);
    removeOverlay(svg);

    // Fit on load
    fitToViewport();

    showLoading(false);
    setStatus(`Deck ${deckNum} ready`);
    showToast(`Deck ${deckNum} loaded`);
  }

  /* =========================
     Zoom & pan (mouse + touch + pinch)
     ========================= */
  function zoomAt(clientX, clientY, factor){
    const rect = stage.getBoundingClientRect();
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    const svgX = (x - tx) / zoom;
    const svgY = (y - ty) / zoom;

    zoom = clamp(zoom * factor, 0.35, 5);
    tx = x - svgX * zoom;
    ty = y - svgY * zoom;
    applyTransform();
  }

  stage.addEventListener('wheel', (e) => {
    e.preventDefault();
    zoomAt(e.clientX, e.clientY, e.deltaY > 0 ? 0.90 : 1.10);
  }, { passive:false });

  stage.addEventListener('pointerdown', (e) => {
    stage.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, {x:e.clientX,y:e.clientY});

    if (pointers.size === 1){
      isDragging = true;
      lastPan = {x:e.clientX,y:e.clientY};
    } else if (pointers.size === 2){
      const pts = Array.from(pointers.values());
      const dx = pts[0].x - pts[1].x;
      const dy = pts[0].y - pts[1].y;
      const dist = Math.hypot(dx,dy);

      const r = stage.getBoundingClientRect();
      const centerX = (pts[0].x + pts[1].x)/2 - r.left;
      const centerY = (pts[0].y + pts[1].y)/2 - r.top;

      pinchStart = { dist, zoom, centerX, centerY };
      isDragging = false;
    }
  });

  stage.addEventListener('pointermove', (e) => {
    if (!pointers.has(e.pointerId)) return;
    pointers.set(e.pointerId, {x:e.clientX,y:e.clientY});

    if (pointers.size === 1 && isDragging){
      const dx = e.clientX - lastPan.x;
      const dy = e.clientY - lastPan.y;
      lastPan = {x:e.clientX,y:e.clientY};
      tx += dx; ty += dy;
      applyTransform();
      return;
    }

    if (pointers.size === 2 && pinchStart){
      const pts = Array.from(pointers.values());
      const dx = pts[0].x - pts[1].x;
      const dy = pts[0].y - pts[1].y;
      const dist = Math.hypot(dx,dy);

      const scale = dist / pinchStart.dist;
      const nextZoom = clamp(pinchStart.zoom * scale, 0.35, 5);

      const x = pinchStart.centerX;
      const y = pinchStart.centerY;

      const svgX = (x - tx) / zoom;
      const svgY = (y - ty) / zoom;

      zoom = nextZoom;
      tx = x - svgX * zoom;
      ty = y - svgY * zoom;
      applyTransform();
    }
  });

  function endPointer(e){
    pointers.delete(e.pointerId);
    if (pointers.size < 2) pinchStart = null;
    if (pointers.size === 0) isDragging = false;
  }
  stage.addEventListener('pointerup', endPointer);
  stage.addEventListener('pointercancel', endPointer);
  stage.addEventListener('pointerleave', endPointer);

  // Double-tap to fit
  let lastTap = 0;
  stage.addEventListener('pointerdown', () => {
    const now = Date.now();
    if (now - lastTap < 280) fitToViewport();
    lastTap = now;
  });

  btnZoomIn.addEventListener('click', () => {
    const r = stage.getBoundingClientRect();
    zoomAt(r.left + r.width/2, r.top + r.height/2, 1.12);
  });
  btnZoomOut.addEventListener('click', () => {
    const r = stage.getBoundingClientRect();
    zoomAt(r.left + r.width/2, r.top + r.height/2, 0.89);
  });
  btnReset.addEventListener('click', () => fitToViewport());

  /* =========================
     Search
     ========================= */
  let searchTimer = 0;
  roomSearch.addEventListener('input', () => {
    clearTimeout(searchTimer);
    searchTimer = setTimeout(() => {
      const q = digits(roomSearch.value);
      if (!q) return;
      highlightRoom(q, {announce:true});
    }, 220);
  });
  roomSearch.addEventListener('keydown', (e) => {
    if (e.key === 'Enter'){
      const q = digits(roomSearch.value);
      if (!q) return;
      highlightRoom(q, {announce:true});
    }
  });

  btnFamily.addEventListener('click', () => highlightFamilyCabins());

  /* =========================
     Deck rail
     ========================= */
  function buildDeckRail(){
    deckRail.innerHTML = '';
    for (const d of DECKS){
      const b = document.createElement('button');
      b.type = 'button';
      b.className = 'deckchip' + (d.n === activeDeck ? ' active' : '');
      b.dataset.deck = String(d.n);
      b.textContent = `Deck ${pad2(d.n)}`;
      b.addEventListener('click', () => loadDeck(d.n));
      deckRail.appendChild(b);
    }
  }

  /* =========================
     Ocean background
     ========================= */
  const octx = ocean.getContext('2d');
  let ot = 0;

  function resizeOcean(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    ocean.width = Math.floor(window.innerWidth * dpr);
    ocean.height = Math.floor(window.innerHeight * dpr);
    ocean.style.width = window.innerWidth + 'px';
    ocean.style.height = window.innerHeight + 'px';
    octx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', () => {
    resizeOcean();
    if (currentSVG && !usingFallbackImg) fitToViewport();
  });

  function drawOcean(){
    const w = window.innerWidth, h = window.innerHeight;
    octx.clearRect(0,0,w,h);
    octx.fillStyle = '#071a2c';
    octx.fillRect(0,0,w,h);

    const g = octx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,'rgba(10,46,74,.10)');
    g.addColorStop(1,'rgba(0,0,0,.32)');
    octx.fillStyle = g;
    octx.fillRect(0,0,w,h);

    for (let i=0;i<3;i++){
      const amp = 22 + i*12;
      const len = 0.010 - i*0.0018;
      const base = h*(0.52 + i*0.07);

      octx.beginPath();
      octx.moveTo(0, base);
      for (let x=0;x<=w;x+=10){
        const y = base + Math.sin(x*len + ot*(0.9+i*0.2)) * amp;
        octx.lineTo(x,y);
      }
      octx.lineTo(w,h); octx.lineTo(0,h);
      octx.closePath();
      octx.fillStyle = `rgba(0,180,230,${0.11 - i*0.03})`;
      octx.fill();
    }

    const reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    ot += reduce ? 0.004 : 0.012;
    requestAnimationFrame(drawOcean);
  }

  /* =========================
     Init
     ========================= */
  function init(){
    resizeOcean();
    drawOcean();

    buildDeckRail();

    if (!DECKS.some(d => d.n === activeDeck)) activeDeck = 6;

    // Start in a known good state
    applyTransform();
    hideError();

    loadDeck(activeDeck);

    showToast('Deck Explorer (auto-path) loaded');
  }

  init();
})();
</script>

</body>
</html>