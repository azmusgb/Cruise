<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Adventure of the Seas Â· Deck Navigator</title>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet" />

  <style>
    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      Reset + Tokens
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; }
    :root{
      --navy:#0A2E4A;
      --navy2:#083452;
      --sea:#0f4f76;
      --aqua:#00b4e6;
      --mint:#4de7c8;
      --sun:#ffb703;
      --coral:#ff6b6b;
      --sand:#efe6d6;
      --glass: rgba(255,255,255,.12);
      --glass2: rgba(255,255,255,.18);
      --shadow: rgba(0,0,0,.55);

      --panelH: 82px;
      --carouselH: 118px;

      --focus: rgba(255,183,3,.95);
      --focusShadow: rgba(255,183,3,.35);
    }

    body{
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:#fff;
      overflow:hidden;
      background:
        radial-gradient(1100px 700px at 18% 20%, rgba(0,180,230,.35), transparent 60%),
        radial-gradient(900px 600px at 80% 28%, rgba(255,183,3,.18), transparent 55%),
        linear-gradient(180deg, var(--sea), var(--navy2));
      position:relative;
    }

    /* ocean shimmer (subtle parallax driven by CSS vars) */
    body::before{
      content:"";
      position:absolute;
      inset:-20%;
      background:
        radial-gradient(circle at 20% 30%, rgba(255,255,255,.10), transparent 55%),
        radial-gradient(circle at 65% 40%, rgba(255,255,255,.08), transparent 60%),
        radial-gradient(circle at 40% 75%, rgba(255,255,255,.06), transparent 60%);
      opacity:.65;
      filter: blur(0.2px);
      transform: translate3d(var(--bgx, 0px), var(--bgy, 0px), 0);
      pointer-events:none;
      will-change: transform;
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      Accessibility helpers
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .sr-only{
      position:absolute;
      width:1px; height:1px;
      padding:0; margin:-1px;
      overflow:hidden; clip:rect(0,0,0,0);
      border:0;
      white-space:nowrap;
    }

    :focus-visible{
      outline: 3px solid var(--focus);
      outline-offset: 3px;
      box-shadow: 0 0 0 4px var(--focusShadow);
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      Header
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .topbar{
      position:relative;
      padding: 22px 18px 16px;
      background: linear-gradient(135deg, rgba(255,183,3,.95), rgba(255,107,107,.85));
      border-bottom-left-radius: 26px;
      border-bottom-right-radius: 26px;
      box-shadow: 0 16px 50px rgba(0,0,0,.35);
    }
    .topbar .kicker{
      letter-spacing: 3px;
      font-size: .75rem;
      opacity:.92;
    }
    .topbar .title{
      margin-top: 6px;
      font-weight: 900;
      font-size: 1.75rem;
      line-height: 1.05;
      text-shadow: 0 8px 30px rgba(0,0,0,.25);
    }
    .topbar .subtitle{
      margin-top: 6px;
      font-weight: 600;
      opacity:.9;
    }
    .topbar .back{
      position:absolute;
      right: 14px;
      top: 18px;
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 10px 14px;
      border-radius: 999px;
      background: rgba(255,255,255,.18);
      border: 1px solid rgba(255,255,255,.26);
      color:#fff;
      text-decoration:none;
      font-weight: 800;
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      box-shadow: 0 12px 28px rgba(0,0,0,.22);
    }
    .topbar .back:active{ transform: scale(.98); }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      Viewer
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .viewer{
      position:absolute;
      left:0; right:0;
      top: 116px;
      bottom: calc(var(--panelH) + var(--carouselH) + 18px);
      padding: 14px 14px 0;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .frame{
      width:100%;
      height:100%;
      border-radius: 28px;
      background: rgba(0,0,0,.14);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
      position:relative;
      overflow:hidden;
      touch-action: none; /* unified PointerEvents for pan/pinch */
    }

    /* glow sweep overlay */
    .frame::after{
      content:"";
      position:absolute;
      inset:-40%;
      background:
        radial-gradient(circle at 25% 40%, rgba(0,180,230,.18), transparent 60%),
        radial-gradient(circle at 65% 55%, rgba(77,231,200,.14), transparent 60%),
        linear-gradient(115deg,
          transparent 0%,
          rgba(255,255,255,.18) 42%,
          rgba(255,255,255,.08) 52%,
          transparent 70%);
      transform: translateX(-35%) rotate(12deg);
      opacity: 0;
      pointer-events:none;
      mix-blend-mode: screen;
    }
    .frame.sweep::after{
      opacity: .85;
      animation: glowSweep 2.4s ease-in-out 1;
    }
    @keyframes glowSweep{
      0%   { transform: translateX(-60%) rotate(12deg); opacity:0; }
      18%  { opacity:.75; }
      55%  { opacity:.9; }
      100% { transform: translateX(60%) rotate(12deg); opacity:0; }
    }

    /* Stage centers content; pan/zoom applied on .panZoom only */
    .stage{
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%, -50%);
      transform-origin: center center;
      width: 0; height: 0;
      pointer-events:none;
    }

    .panZoom{
      position:absolute;
      left:0; top:0;
      transform-origin: center center;
      will-change: transform;
      transition: transform 240ms cubic-bezier(.2,.8,.25,1);
      pointer-events:auto; /* actual interaction surface */
    }

    .deckShell{
      position:relative;
      display:grid;
      place-items:center;
      filter: drop-shadow(0 30px 60px rgba(0,0,0,.55));
      opacity: 1;
      transition: opacity 220ms ease;
    }

    .deckObject{
      width:min(920px, calc(100vw - 40px));
      height:auto;
      display:block;
      border-radius: 28px;
      background: var(--sand);
      box-shadow:
        0 0 0 10px rgba(255,255,255,.16),
        0 0 0 1px rgba(0,0,0,.10),
        0 0 80px rgba(0,180,230,.20),
        0 35px 90px rgba(0,0,0,.55);
    }

    /* edge glow "lighting" */
    .edgeGlow{
      position:absolute;
      inset:-10px;
      border-radius: 34px;
      pointer-events:none;
      background:
        radial-gradient(circle at 30% 25%, rgba(0,180,230,.30), transparent 55%),
        radial-gradient(circle at 70% 75%, rgba(77,231,200,.22), transparent 58%),
        radial-gradient(circle at 50% 50%, rgba(255,255,255,.12), transparent 65%);
      opacity:.85;
      filter: blur(0.2px);
      z-index:-1;
    }

    /* hotspots in same centered coordinate system as deck */
    .hotspots{
      position:absolute;
      left:50%;
      top:50%;
      width:0;
      height:0;
      pointer-events:none;
    }

    .hotspot{
      position:absolute;
      transform: translate(-50%, -50%);
      pointer-events:auto;
      display:flex;
      align-items:center;
      gap:10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(10,46,74,.72);
      border: 1px solid rgba(255,255,255,.22);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      cursor:pointer;
      user-select:none;
      max-width: min(72vw, 360px);
    }
    .hotspot:active{ transform: translate(-50%, -50%) scale(.98); }
    .hotspot .dot{
      width: 14px; height:14px; border-radius:999px;
      background: radial-gradient(circle at 30% 30%, #fff, rgba(255,255,255,.25));
      box-shadow: 0 0 0 4px rgba(0,180,230,.25), 0 0 20px rgba(0,180,230,.55);
      flex: 0 0 auto;
    }
    .hotspot .label{
      font-weight:900;
      font-size:.9rem;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .hotspot .emoji{
      font-size: 1.05rem;
      opacity:.95;
      flex: 0 0 auto;
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      Bottom carousel (JS-rendered only)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .carouselWrap{
      position:absolute;
      left:0; right:0;
      bottom: var(--panelH);
      height: var(--carouselH);
      padding: 10px 10px 12px;
      display:flex;
      align-items:flex-end;
      pointer-events:auto;
    }
    .carousel{
      width:100%;
      display:flex;
      gap: 12px;
      overflow:auto;
      padding: 6px 6px 10px;
      scroll-snap-type: x mandatory;
      -webkit-overflow-scrolling: touch;
    }
    .carousel::-webkit-scrollbar{ height: 0; }

    .card{
      flex: 0 0 110px;
      height: 96px;
      border-radius: 18px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.16);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      box-shadow: 0 20px 40px rgba(0,0,0,.28);
      overflow:hidden;
      position:relative;
      scroll-snap-align: start;
      cursor:pointer;
      user-select:none;
      color:#fff;
      padding: 0;
    }
    .card[aria-selected="true"]{
      border-color: rgba(255,183,3,.85);
      box-shadow:
        0 22px 50px rgba(0,0,0,.34),
        0 0 0 2px rgba(255,183,3,.35) inset;
    }
    .thumb{
      position:absolute;
      inset:0;
      background: rgba(0,0,0,.10);
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .thumb img{
      width: 92%;
      height: 92%;
      object-fit: contain;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.35));
    }
    .card .meta{
      position:absolute;
      left:0; right:0; bottom:0;
      padding: 8px 10px;
      background: linear-gradient(180deg, transparent, rgba(0,0,0,.50));
      font-weight: 900;
      letter-spacing:.3px;
      font-size:.9rem;
      text-align:left;
    }
    .card .meta small{
      display:block;
      font-weight:800;
      opacity:.85;
      font-size:.75rem;
      margin-top:2px;
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      Controls
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .controls{
      position:absolute;
      left:50%;
      bottom: 14px;
      transform: translateX(-50%);
      height: var(--panelH);
      padding: 10px 14px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(0,180,230,.92), rgba(15,79,118,.92));
      border: 1px solid rgba(255,255,255,.20);
      display:flex;
      align-items:center;
      gap: 12px;
      box-shadow: 0 26px 70px rgba(0,0,0,.55);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
    }
    .btn{
      width: 56px;
      height: 56px;
      border-radius: 999px;
      border:none;
      cursor:pointer;
      background: rgba(255,255,255,.92);
      color: var(--navy);
      font-size: 24px;
      font-weight: 900;
      display:grid;
      place-items:center;
      box-shadow: 0 16px 26px rgba(0,0,0,.25);
      user-select:none;
    }
    .btn:active{ transform: scale(.94); }
    .zoomPct{
      width: 90px;
      text-align:center;
      font-weight: 900;
      font-size: 1.15rem;
      letter-spacing:.6px;
      color:#fff;
      text-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    .btnReset{
      width:auto;
      padding: 0 18px;
      font-size: 1rem;
      font-weight: 900;
      background: linear-gradient(135deg, rgba(77,231,200,.95), rgba(255,255,255,.92));
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      Error overlay
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .errorOverlay{
      position:absolute;
      inset: 14px;
      border-radius: 24px;
      background: rgba(10,46,74,.80);
      border: 1px solid rgba(255,255,255,.18);
      box-shadow: 0 26px 90px rgba(0,0,0,.65);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      padding: 16px;
      display:none;
      z-index: 40;
    }
    .errorOverlay.show{ display:block; }
    .errorTitle{
      font-weight: 900;
      font-size: 1.2rem;
      letter-spacing:.2px;
    }
    .errorDesc{
      margin-top: 8px;
      opacity:.92;
      line-height: 1.35;
    }
    .errorActions{
      margin-top: 12px;
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      Venue popup (bottom sheet)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .sheet{
      position:absolute;
      left:0; right:0; bottom:-60%;
      padding: 14px 14px 18px;
      transition: transform 320ms cubic-bezier(.2,.8,.25,1);
      transform: translateY(0);
      z-index: 30;
      pointer-events:none;
    }
    .sheet.open{
      transform: translateY(-58%);
      pointer-events:auto;
    }
    .sheetInner{
      margin: 0 auto;
      max-width: 740px;
      border-radius: 24px;
      background: rgba(10,46,74,.76);
      border: 1px solid rgba(255,255,255,.18);
      box-shadow: 0 26px 90px rgba(0,0,0,.65);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      overflow:hidden;
    }
    .sheetTop{
      padding: 12px 14px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      background: rgba(255,255,255,.08);
    }
    .grab{
      width: 44px; height: 5px;
      border-radius: 999px;
      background: rgba(255,255,255,.35);
      margin: 0 auto;
    }
    .sheetBody{
      padding: 14px 16px 16px;
    }
    .venueTitle{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight: 900;
      font-size: 1.2rem;
      letter-spacing:.2px;
    }
    .venueDesc{
      margin-top: 8px;
      opacity:.92;
      line-height: 1.35;
    }
    .sheetActions{
      margin-top: 14px;
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
    }
    .pill{
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.20);
      background: rgba(255,255,255,.10);
      color:#fff;
      text-decoration:none;
      font-weight: 900;
      cursor:pointer;
      user-select:none;
    }
    .pill.primary{
      background: linear-gradient(135deg, rgba(255,183,3,.95), rgba(255,107,107,.85));
      border-color: rgba(255,255,255,.20);
      color:#08263d;
    }

    /* backdrop click-catcher when sheet is open */
    .backdrop{
      position:absolute;
      inset:0;
      background: transparent;
      z-index: 25;
      display:none;
    }
    .backdrop.show{ display:block; }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      Responsive tweaks
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    @media (max-width: 430px){
      .topbar .title{ font-size: 1.55rem; }
      .card{ flex-basis: 104px; }
      .controls{ width: calc(100% - 16px); justify-content:center; }
      .zoomPct{ width: 80px; }
    }

    /* reduce motion support */
    @media (prefers-reduced-motion: reduce){
      .panZoom, .sheet, .frame.sweep::after { transition:none !important; animation:none !important; }
      body::before{ transition:none !important; }
    }
  </style>
</head>

<body>
  <header class="topbar" aria-label="Deck viewer header">
    <a class="back" href="index.html" aria-label="Back to decks">â† Back</a>
    <div class="kicker">ADVENTURE OF THE SEAS</div>
    <div class="title" id="hdrTitle">Deck Navigator</div>
    <div class="subtitle" id="hdrSub">Swipe to change decks Â· Pinch/drag to explore Â· Tap venues</div>
  </header>

  <main class="viewer" aria-label="Deck viewer">
    <div class="frame" id="frame" aria-label="Interactive deck frame">
      <div class="stage" aria-hidden="true">
        <div class="panZoom" id="panZoom">
          <div class="deckShell" id="deckShell">
            <div class="edgeGlow" aria-hidden="true"></div>

            <!-- JS is single source of truth: no hardcoded data attribute -->
            <object class="deckObject" id="deckObject" type="image/svg+xml" aria-label="Deck plan"></object>

            <div class="hotspots" id="hotspots" aria-label="Venue hotspots"></div>
          </div>
        </div>
      </div>

      <!-- Error overlay -->
      <div class="errorOverlay" id="errorOverlay" role="alert" aria-live="assertive">
        <div class="errorTitle" id="errorTitle">Deck failed to load</div>
        <div class="errorDesc" id="errorDesc">We couldnâ€™t load the SVG for this deck. Check the file path and try again.</div>
        <div class="errorActions">
          <button class="pill primary" id="retryLoad" type="button">Retry</button>
          <button class="pill" id="copyPath" type="button">Copy SVG path</button>
          <button class="pill" id="goPrevDeck" type="button">Previous deck</button>
          <button class="pill" id="goNextDeck" type="button">Next deck</button>
        </div>
      </div>

      <!-- Backdrop click-catcher (for sheet open) -->
      <div class="backdrop" id="backdrop" aria-hidden="true"></div>
    </div>
  </main>

  <section class="carouselWrap" aria-label="Deck carousel">
    <div class="carousel" id="carousel" role="listbox" aria-label="Select a deck"></div>
  </section>

  <nav class="controls" aria-label="Zoom controls">
    <button class="btn" id="zoomOut" type="button" aria-label="Zoom out">âˆ’</button>
    <div class="zoomPct" id="zoomLabel" aria-live="polite">100%</div>
    <button class="btn" id="zoomIn" type="button" aria-label="Zoom in">+</button>
    <button class="btn btnReset" id="resetZoom" type="button" aria-label="Reset view">Reset</button>
    <span class="sr-only" id="gestureHint">Use two fingers to pinch zoom and drag to pan.</span>
  </nav>

  <!-- Venue sheet -->
  <div class="sheet" id="sheet" aria-hidden="true">
    <div class="sheetInner" role="dialog" aria-modal="true" aria-labelledby="venueTitle" aria-describedby="venueDesc">
      <div class="sheetTop">
        <div class="grab" aria-hidden="true"></div>
        <button class="pill" id="closeSheet" type="button" aria-label="Close venue popup">Close</button>
      </div>
      <div class="sheetBody">
        <div class="venueTitle" id="venueTitle">ğŸ“ Venue</div>
        <div class="venueDesc" id="venueDesc">Detailsâ€¦</div>
        <div class="sheetActions">
          <button class="pill primary" id="centerOnVenue" type="button">Center on venue</button>
          <button class="pill" id="glowSweep" type="button">Glow sweep</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Deck Data
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const DECKS = [
    { id: "02", name: "Deck 02", subtitle: "Lower Promenade", svg: "decks/deck-02-final.min.svg", hotspots: [] },
    {
      id: "03", name: "Deck 03", subtitle: "Promenade", svg: "decks/deck-03-final.min.svg",
      hotspots: [
        { id:"duck",  x:0.70, y:0.33, emoji:"ğŸº", title:"The Duck & Dog Pub", desc:"Classic pub energy. Good place to regroup the crew." },
        { id:"shops", x:0.80, y:0.45, emoji:"ğŸ›ï¸", title:"Shops", desc:"Souvenirs and last-minute cruise essentials." }
      ]
    },
    {
      id: "04", name: "Deck 04", subtitle: "Entertainment", svg: "decks/deck-04-final.min.svg",
      hotspots: [
        { id:"lyric",   x:0.52, y:0.16, emoji:"ğŸ­", title:"Lyric Theatre", desc:"Showtime. Big seats, big sound, big family wow." },
        { id:"casino",  x:0.47, y:0.50, emoji:"ğŸ°", title:"Casino Royale", desc:"Bright lights, blackjack dreams, and suspiciously confident uncles." },
        { id:"schooner",x:0.67, y:0.40, emoji:"ğŸ¸", title:"Schooner Bar", desc:"Cocktails + live music vibes. A+ pre-dinner stop." },
        { id:"boleros", x:0.35, y:0.69, emoji:"ğŸ’ƒ", title:"Boleros", desc:"Latin music, dancing, and the official home of 'one more song'." },
        { id:"mdr",     x:0.52, y:0.88, emoji:"ğŸ½ï¸", title:"Main Dining Room", desc:"The classic dinner ritual. Everyone looks fancy for 37 minutes." }
      ]
    },
    { id: "05", name: "Deck 05", subtitle: "Promenade", svg: "decks/deck-05-final.min.svg", hotspots: [] }
  ];

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    DOM
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const frame      = document.getElementById("frame");
  const panZoomEl  = document.getElementById("panZoom");
  const deckShell  = document.getElementById("deckShell");
  const deckObj    = document.getElementById("deckObject");
  const hotspotsEl = document.getElementById("hotspots");

  const hdrTitle   = document.getElementById("hdrTitle");
  const hdrSub     = document.getElementById("hdrSub");

  const carousel   = document.getElementById("carousel");

  const zoomLabel  = document.getElementById("zoomLabel");
  const zoomInBtn  = document.getElementById("zoomIn");
  const zoomOutBtn = document.getElementById("zoomOut");
  const resetBtn   = document.getElementById("resetZoom");

  const sheet      = document.getElementById("sheet");
  const backdrop   = document.getElementById("backdrop");
  const closeSheetBtn = document.getElementById("closeSheet");
  const venueTitle = document.getElementById("venueTitle");
  const venueDesc  = document.getElementById("venueDesc");
  const centerOnVenueBtn = document.getElementById("centerOnVenue");
  const glowSweepBtn = document.getElementById("glowSweep");

  const errorOverlay = document.getElementById("errorOverlay");
  const errorTitle   = document.getElementById("errorTitle");
  const errorDesc    = document.getElementById("errorDesc");
  const retryLoadBtn = document.getElementById("retryLoad");
  const copyPathBtn  = document.getElementById("copyPath");
  const goPrevDeckBtn= document.getElementById("goPrevDeck");
  const goNextDeckBtn= document.getElementById("goNextDeck");

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Defensive check
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const REQUIRED = [
    frame, panZoomEl, deckShell, deckObj, hotspotsEl,
    hdrTitle, hdrSub, carousel,
    zoomLabel, zoomInBtn, zoomOutBtn, resetBtn,
    sheet, backdrop, closeSheetBtn, venueTitle, venueDesc, centerOnVenueBtn, glowSweepBtn,
    errorOverlay, retryLoadBtn, copyPathBtn, goPrevDeckBtn, goNextDeckBtn
  ];
  if (REQUIRED.some(n => !n)) {
    // Hard fail with readable message (prevents silent null crashes)
    const msg = "Deck Navigator: missing required DOM elements. Check IDs in the HTML.";
    console.error(msg);
    alert(msg);
    return;
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    State
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
  const reduceMotion = window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;

  const MIN_SCALE = 0.35;
  const MAX_SCALE = 5.0;

  // JS is single source of truth:
  // - default deck = 05
  // - optional URL: ?deck=04 or #deck=04
  function getInitialDeckId(){
    const url = new URL(window.location.href);
    const q = (url.searchParams.get("deck") || "").trim();
    const h = (url.hash || "").replace("#","").trim();
    const fromHash = h.startsWith("deck=") ? h.slice(5) : h;
    const candidate = (q || fromHash || "05").padStart(2, "0");
    return candidate;
  }

  let activeIndex = (() => {
    const id = getInitialDeckId();
    const idx = DECKS.findIndex(d => d.id === id);
    return idx >= 0 ? idx : Math.max(0, DECKS.findIndex(d => d.id === "05"));
  })();

  let scale = 1;
  let tx = 0;
  let ty = 0;
  let fitScale = 1;

  // measured deck size at scale=1, tx=ty=0 (in CSS px)
  let baseDeckW = 800;
  let baseDeckH = 1200;

  // First load intro only once
  let didIntro = false;

  // Venue selection
  let currentVenue = null;
  let lastFocusEl = null;

  // Gesture state (PointerEvents only)
  /** @type {Map<number, {x:number,y:number}>} */
  const pointers = new Map();
  let gestureMode = "none"; // "none" | "pan" | "pinch"
  let panStart = { x:0, y:0, tx:0, ty:0 };
  let pinchStart = { dist:0, scale:1, centerX:0, centerY:0, tx:0, ty:0 };

  // Parallax smoothing (rAF)
  let parallaxTarget = { x:0, y:0 };
  let parallaxRAF = 0;

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Utilities
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  function setOceanParallax(dx, dy){
    parallaxTarget.x = dx * 0.03;
    parallaxTarget.y = dy * 0.03;
    if (parallaxRAF) return;
    parallaxRAF = requestAnimationFrame(() => {
      parallaxRAF = 0;
      document.body.style.setProperty("--bgx", `${parallaxTarget.x}px`);
      document.body.style.setProperty("--bgy", `${parallaxTarget.y}px`);
    });
  }

  function runGlowSweep(){
    frame.classList.remove("sweep");
    void frame.offsetHeight;
    frame.classList.add("sweep");
  }

  function setHeader(deck){
    hdrTitle.textContent = `${deck.name} Â· ${deck.subtitle}`;
    hdrSub.textContent = "Swipe to change decks Â· Pinch/drag to explore Â· Tap venues";
  }

  function setZoomLabel(){
    // display zoom relative to fit (more intuitive)
    const pct = Math.round((scale / fitScale) * 100);
    zoomLabel.textContent = `${pct}%`;
  }

  function applyTransform(){
    panZoomEl.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
    setZoomLabel();
  }

  function withNoTransition(fn){
    const prev = panZoomEl.style.transition;
    panZoomEl.style.transition = "none";
    fn();
    void panZoomEl.offsetHeight;
    panZoomEl.style.transition = prev || "transform 240ms cubic-bezier(.2,.8,.25,1)";
  }

  function computeFitScale(){
    const f = frame.getBoundingClientRect();
    const margin = 18;
    const availableW = Math.max(200, f.width  - margin);
    const availableH = Math.max(200, f.height - margin);
    const sW = availableW / baseDeckW;
    const sH = availableH / baseDeckH;
    const s = Math.min(sW, sH);
    return clamp(s, MIN_SCALE, MAX_SCALE);
  }

  function clampPan(){
    const f = frame.getBoundingClientRect();
    const padding = 18;

    const scaledW = baseDeckW * scale;
    const scaledH = baseDeckH * scale;

    const maxX = Math.max(0, (scaledW - f.width) / 2) + padding;
    const maxY = Math.max(0, (scaledH - f.height) / 2) + padding;

    tx = clamp(tx, -maxX, maxX);
    ty = clamp(ty, -maxY, maxY);
  }

  function resetToFit(animated=true){
    const doIt = () => {
      fitScale = computeFitScale();
      scale = fitScale;
      tx = 0;
      ty = 0;
      clampPan();
      applyTransform();
    };
    if (!animated) withNoTransition(doIt);
    else doIt();
  }

  function getFrameCenterClient(){
    const r = frame.getBoundingClientRect();
    return { cx: r.left + r.width / 2, cy: r.top + r.height / 2 };
  }

  function zoomTo(newScale, centerClientX, centerClientY){
    newScale = clamp(newScale, MIN_SCALE, MAX_SCALE);
    if (newScale === scale) return;

    const { cx, cy } = getFrameCenterClient();
    const px = (centerClientX ?? cx);
    const py = (centerClientY ?? cy);

    // Keep point under cursor stable:
    // screen = frameCenter + tx + local*scale
    // local = (screen - frameCenter - tx)/scale
    const localX = (px - cx - tx) / scale;
    const localY = (py - cy - ty) / scale;

    scale = newScale;
    tx = (px - cx) - localX * scale;
    ty = (py - cy) - localY * scale;

    clampPan();
    applyTransform();
  }

  function zoomAt(factor, centerClientX, centerClientY){
    zoomTo(scale * factor, centerClientX, centerClientY);
  }

  function showError(message, path){
    errorTitle.textContent = "Deck failed to load";
    errorDesc.textContent = message || "We couldnâ€™t load the SVG for this deck. Check the file path and try again.";
    errorOverlay.dataset.path = path || "";
    errorOverlay.classList.add("show");
  }

  function hideError(){
    errorOverlay.classList.remove("show");
    errorOverlay.dataset.path = "";
  }

  async function copyText(text){
    try{
      if (navigator.clipboard && navigator.clipboard.writeText){
        await navigator.clipboard.writeText(text);
        return true;
      }
    } catch {}
    // fallback
    try{
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.setAttribute("readonly", "true");
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      return ok;
    } catch {
      return false;
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Carousel (A11y)
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  function buildCarousel(){
    carousel.innerHTML = "";
    for (let i = 0; i < DECKS.length; i++){
      const d = DECKS[i];
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "card";
      btn.setAttribute("role", "option");
      btn.setAttribute("aria-selected", i === activeIndex ? "true" : "false");
      btn.dataset.index = String(i);
      btn.innerHTML = `
        <div class="thumb"><img alt="${d.name} thumbnail" src="${d.svg}"></div>
        <div class="meta">${d.name}<small>${d.subtitle}</small></div>
      `;
      btn.addEventListener("click", () => switchToDeck(i, { reason: "carousel" }));
      btn.addEventListener("keydown", (e) => {
        // allow horizontal navigation on carousel itself
        if (e.key === "ArrowLeft") { e.preventDefault(); switchToDeck(activeIndex - 1, { reason:"kbd" }); }
        if (e.key === "ArrowRight"){ e.preventDefault(); switchToDeck(activeIndex + 1, { reason:"kbd" }); }
        if (e.key === "Home"){ e.preventDefault(); switchToDeck(0, { reason:"kbd" }); }
        if (e.key === "End"){ e.preventDefault(); switchToDeck(DECKS.length - 1, { reason:"kbd" }); }
      });
      carousel.appendChild(btn);
    }
    setActiveCard(true);
  }

  function setActiveCard(scroll){
    const cards = carousel.querySelectorAll(".card");
    cards.forEach((c, idx) => c.setAttribute("aria-selected", idx === activeIndex ? "true" : "false"));
    const active = carousel.querySelector(`.card[data-index="${activeIndex}"]`);
    if (active && scroll && active.scrollIntoView) {
      active.scrollIntoView({ behavior: "smooth", inline: "center", block: "nearest" });
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Hotspots (no boundingClientRect loops)
    - We anchor at deck center.
    - We place hotspots by (x,y) as fractions of measured deck size at scale=1.
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  function clearHotspots(){
    hotspotsEl.innerHTML = "";
  }

  function renderHotspots(deck){
    clearHotspots();
    if (!deck.hotspots || deck.hotspots.length === 0) return;

    for (const hs of deck.hotspots){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "hotspot";
      btn.setAttribute("aria-label", hs.title);
      btn.dataset.x = String(hs.x);
      btn.dataset.y = String(hs.y);
      btn.dataset.emoji = hs.emoji || "ğŸ“";
      btn.dataset.title = hs.title;
      btn.dataset.desc = hs.desc || "";

      // Convert [0..1] to centered px coordinates (scale=1 coordinate system)
      const vx = (hs.x - 0.5) * baseDeckW;
      const vy = (hs.y - 0.5) * baseDeckH;

      btn.style.left = `${vx}px`;
      btn.style.top  = `${vy}px`;

      btn.innerHTML = `
        <span class="dot" aria-hidden="true"></span>
        <span class="emoji" aria-hidden="true">${hs.emoji || "ğŸ“"}</span>
        <span class="label">${hs.title}</span>
      `;

      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        openVenue(deck, hs, btn);
      });

      hotspotsEl.appendChild(btn);
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Sheet (A11y focus trap + inert background)
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  function setSheetOpen(isOpen){
    sheet.classList.toggle("open", isOpen);
    sheet.setAttribute("aria-hidden", isOpen ? "false" : "true");

    backdrop.classList.toggle("show", isOpen);
    backdrop.setAttribute("aria-hidden", isOpen ? "false" : "true");

    // Make the rest of UI inert-ish
    // (Safari support varies, but harmless)
    const toInert = [frame, carousel, zoomInBtn, zoomOutBtn, resetBtn, document.querySelector(".topbar")].filter(Boolean);
    for (const el of toInert){
      if (isOpen){
        el.setAttribute("aria-hidden", "true");
        try { el.inert = true; } catch {}
      } else {
        el.removeAttribute("aria-hidden");
        try { el.inert = false; } catch {}
      }
    }
  }

  function openVenue(deck, venue, invokerEl){
    currentVenue = { deck, venue };
    lastFocusEl = invokerEl || document.activeElement;

    venueTitle.textContent = `${venue.emoji || "ğŸ“"} ${venue.title}`;
    venueDesc.textContent  = venue.desc || "";

    setSheetOpen(true);
    runGlowSweep();

    // focus the close button for consistent keyboard UX
    closeSheetBtn.focus({ preventScroll: true });
  }

  function closeVenue(){
    currentVenue = null;
    setSheetOpen(false);

    // restore focus
    const el = lastFocusEl;
    lastFocusEl = null;
    if (el && typeof el.focus === "function") el.focus({ preventScroll: true });
  }

  function centerOnVenue(){
    if (!currentVenue) return;
    const { venue } = currentVenue;

    // Correct math in a single coordinate system:
    // In our model, deck center is at (0,0) in panZoom local coords.
    // Venue local coords at scale=1:
    const vx = (venue.x - 0.5) * baseDeckW;
    const vy = (venue.y - 0.5) * baseDeckH;

    // Want venue at frame center:
    // screen = frameCenter + tx + vx*scale
    // set tx = -vx*scale, ty = -vy*scale
    tx = -vx * scale;
    ty = -vy * scale;

    clampPan();
    applyTransform();
    runGlowSweep();
  }

  function trapFocusInSheet(e){
    if (!sheet.classList.contains("open")) return;

    if (e.key === "Escape"){
      e.preventDefault();
      closeVenue();
      return;
    }

    if (e.key !== "Tab") return;

    const focusables = sheet.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    const list = Array.from(focusables).filter(el => !el.hasAttribute("disabled") && el.offsetParent !== null);
    if (list.length === 0) return;

    const first = list[0];
    const last  = list[list.length - 1];

    if (e.shiftKey && document.activeElement === first){
      e.preventDefault();
      last.focus();
    } else if (!e.shiftKey && document.activeElement === last){
      e.preventDefault();
      first.focus();
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Deck loading with failure UI
    - Use fetch HEAD/GET to verify path before setting <object data=...>
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  let pendingDeckPath = "";

  async function verifySvgPath(path){
    // GitHub Pages serves same-origin, so fetch works.
    // Use GET (not HEAD) for broader compatibility.
    try{
      const res = await fetch(path, { method: "GET", cache: "no-cache" });
      if (!res.ok) return { ok:false, status: res.status };
      const ct = (res.headers.get("content-type") || "").toLowerCase();
      // some servers send image/svg+xml; some send text/plain; accept both
      if (ct && !(ct.includes("svg") || ct.includes("text"))) {
        // still might be SVG; don't hard fail on CT
      }
      return { ok:true, status: res.status };
    } catch (e){
      return { ok:false, status: 0 };
    }
  }

  async function loadDeckSvg(deck, opts = { intro: false }){
    hideError();
    pendingDeckPath = deck.svg;

    // Fade during switch
    deckShell.style.opacity = "0";

    const check = await verifySvgPath(deck.svg);
    if (!check.ok){
      deckShell.style.opacity = "1";
      showError(`Couldnâ€™t load: ${deck.svg} (HTTP ${check.status || "network error"}).`, deck.svg);
      return;
    }

    // Now set <object> data and wait for onload
    // Use a load token to ignore old loads
    const token = Math.random().toString(16).slice(2);
    deckObj.dataset.loadToken = token;

    // Set data a tick later so opacity transition reads cleanly
    setTimeout(() => {
      if (pendingDeckPath !== deck.svg) return;
      deckObj.setAttribute("data", deck.svg);
    }, 60);

    // Wait for object to load
    await new Promise((resolve) => {
      const onLoad = () => {
        if (deckObj.dataset.loadToken !== token) return;
        deckObj.removeEventListener("load", onLoad);
        resolve();
      };
      deckObj.addEventListener("load", onLoad, { once: false });
    });

    // Reveal
    deckShell.style.opacity = "1";

    // Measure deck (scale=1, tx=ty=0) so hotspots + fit are coherent
    withNoTransition(() => {
      scale = 1;
      tx = 0;
      ty = 0;
      applyTransform();
    });

    // Measure base deck size
    const r = deckObj.getBoundingClientRect();
    baseDeckW = Math.max(200, r.width || baseDeckW);
    baseDeckH = Math.max(200, r.height || baseDeckH);

    // Fit
    resetToFit(false);

    // Hotspots for active deck
    renderHotspots(deck);

    // Intro only once, only on first successful load
    if (opts.intro && !didIntro && !reduceMotion){
      didIntro = true;
      cinematicIntro();
    } else {
      runGlowSweep();
    }
  }

  function cinematicIntro(){
    const startScale = clamp(fitScale * 0.72, MIN_SCALE, MAX_SCALE);
    const midScale   = clamp(fitScale * 1.05, MIN_SCALE, MAX_SCALE);

    withNoTransition(() => {
      scale = startScale;
      tx = 0;
      ty = 0;
      applyTransform();
    });

    requestAnimationFrame(() => {
      runGlowSweep();

      // Use Web Animations API on panZoomEl (not stage)
      panZoomEl.animate(
        [
          { transform: `translate(0px, 0px) scale(${startScale})` },
          { transform: `translate(0px, 0px) scale(${fitScale})` }
        ],
        { duration: 820, easing: "cubic-bezier(.2,.8,.25,1)", fill: "forwards" }
      );

      setTimeout(() => {
        panZoomEl.animate(
          [
            { transform: `translate(0px, 0px) scale(${fitScale})` },
            { transform: `translate(0px, 0px) scale(${midScale})` },
            { transform: `translate(0px, 0px) scale(${fitScale})` }
          ],
          { duration: 780, easing: "cubic-bezier(.2,.8,.25,1)", fill: "forwards" }
        );
      }, 900);

      setTimeout(() => {
        scale = fitScale;
        tx = 0;
        ty = 0;
        applyTransform();
        clampPan();
        applyTransform();
      }, 1750);
    });
  }

  function switchToDeck(index, opts = { reason: "unknown" }){
    const nextIndex = clamp(index, 0, DECKS.length - 1);
    if (nextIndex === activeIndex) return;

    closeVenue();
    activeIndex = nextIndex;

    const deck = DECKS[activeIndex];
    setHeader(deck);
    setActiveCard(true);

    // Update URL (non-invasive)
    try{
      const url = new URL(window.location.href);
      url.searchParams.set("deck", deck.id);
      history.replaceState(null, "", url.toString());
    } catch {}

    // Load
    loadDeckSvg(deck, { intro: false });
  }

  function nextDeck(){ switchToDeck(activeIndex + 1, { reason:"next" }); }
  function prevDeck(){ switchToDeck(activeIndex - 1, { reason:"prev" }); }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    PointerEvents gestures (unified pan + pinch)
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  function pointerDistance(a, b){
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.hypot(dx, dy);
  }

  function pointerCenter(a, b){
    return { x: (a.x + b.x)/2, y: (a.y + b.y)/2 };
  }

  function beginPan(e){
    gestureMode = "pan";
    panStart = { x: e.clientX, y: e.clientY, tx, ty };
  }

  function beginPinch(){
    gestureMode = "pinch";
    const pts = Array.from(pointers.values());
    const a = pts[0], b = pts[1];
    const c = pointerCenter(a, b);
    pinchStart = {
      dist: Math.max(10, pointerDistance(a, b)),
      scale,
      centerX: c.x,
      centerY: c.y,
      tx,
      ty
    };
  }

  function onPointerDown(e){
    // Avoid interactions when error overlay is up
    if (errorOverlay.classList.contains("show")) return;
    if (sheet.classList.contains("open")) return;

    frame.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    if (pointers.size === 1){
      beginPan(e);
    } else if (pointers.size === 2){
      beginPinch();
    }

    // Stop native behaviors
    e.preventDefault();
  }

  function onPointerMove(e){
    if (!pointers.has(e.pointerId)) return;
    pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    if (sheet.classList.contains("open")) return;

    if (pointers.size === 1 && gestureMode === "pan"){
      const dx = e.clientX - panStart.x;
      const dy = e.clientY - panStart.y;
      tx = panStart.tx + dx;
      ty = panStart.ty + dy;

      clampPan();
      applyTransform();
      setOceanParallax(dx, dy);
      return;
    }

    if (pointers.size >= 2){
      // pinch dominates when two pointers are active
      if (gestureMode !== "pinch") beginPinch();

      const pts = Array.from(pointers.values());
      const a = pts[0], b = pts[1];
      const dist = Math.max(10, pointerDistance(a, b));
      const c = pointerCenter(a, b);

      const factor = dist / pinchStart.dist;
      const targetScale = clamp(pinchStart.scale * factor, MIN_SCALE, MAX_SCALE);

      // Apply zoom around pinch center
      // Reset to pinchStart translation baseline to avoid cumulative drift
      // then zoomTo handles precise stabilization
      tx = pinchStart.tx;
      ty = pinchStart.ty;
      scale = pinchStart.scale;
      applyTransform();

      zoomTo(targetScale, c.x, c.y);

      setOceanParallax(c.x - pinchStart.centerX, c.y - pinchStart.centerY);
      return;
    }
  }

  function onPointerUp(e){
    if (!pointers.has(e.pointerId)) return;
    pointers.delete(e.pointerId);

    setOceanParallax(0, 0);

    if (pointers.size === 0){
      gestureMode = "none";
      // Swipe deck change heuristic: only when near fit and not panned far
      // We canâ€™t rely on dx here directly (pointerup event might be last pointer after pinch)
      // so we use velocity-free heuristic: if user ended with pointer count 0 and deck is near fit, do nothing.
      return;
    }

    if (pointers.size === 1){
      // Transition back to pan with remaining pointer
      const remaining = Array.from(pointers.entries())[0];
      const pt = remaining[1];
      beginPan({ clientX: pt.x, clientY: pt.y });
    }

    e.preventDefault();
  }

  /* Swipe deck change (single-finger) using pointer history */
  let lastPanDx = 0;
  let lastPanDy = 0;
  function trackPanDelta(e){
    if (pointers.size !== 1 || gestureMode !== "pan") return;
    lastPanDx = e.clientX - panStart.x;
    lastPanDy = e.clientY - panStart.y;
  }

  function maybeSwipeDeck(){
    // Only when:
    // - near fit (scale close to fitScale)
    // - mostly horizontal
    // - not panned far (user is â€œat centerâ€)
    const nearFit = Math.abs((scale / fitScale) - 1) < 0.10;
    const horizontal = Math.abs(lastPanDx) > Math.abs(lastPanDy) * 1.5;
    const farEnough = Math.abs(lastPanDx) > 60;
    const notPannedFar = Math.abs(tx) < 50 && Math.abs(ty) < 50;

    if (nearFit && horizontal && farEnough && notPannedFar){
      if (lastPanDx < 0) nextDeck();
      else prevDeck();
    }
    lastPanDx = 0;
    lastPanDy = 0;
  }

  frame.addEventListener("pointerdown", onPointerDown);
  frame.addEventListener("pointermove", (e) => { trackPanDelta(e); onPointerMove(e); });
  frame.addEventListener("pointerup", (e) => { onPointerUp(e); maybeSwipeDeck(); });
  frame.addEventListener("pointercancel", (e) => { onPointerUp(e); });

  // Clicking empty space closes sheet (when open)
  backdrop.addEventListener("click", () => closeVenue());

  // Prevent clicks on frame from doing odd things when sheet open
  frame.addEventListener("click", () => {
    if (sheet.classList.contains("open")) closeVenue();
  });

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Controls
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  zoomInBtn.addEventListener("click", () => {
    zoomAt(1.18);
    runGlowSweep();
  });

  zoomOutBtn.addEventListener("click", () => {
    zoomAt(1/1.18);
    runGlowSweep();
  });

  resetBtn.addEventListener("click", () => {
    resetToFit(true);
    runGlowSweep();
  });

  glowSweepBtn.addEventListener("click", () => runGlowSweep());

  closeSheetBtn.addEventListener("click", () => closeVenue());

  centerOnVenueBtn.addEventListener("click", () => centerOnVenue());

  document.addEventListener("keydown", (e) => {
    // Focus trap for dialog
    trapFocusInSheet(e);

    if (sheet.classList.contains("open")) return;

    // Global shortcuts
    if (e.key === "ArrowLeft") { e.preventDefault(); prevDeck(); }
    if (e.key === "ArrowRight") { e.preventDefault(); nextDeck(); }
    if (e.key === "+" || e.key === "=") { e.preventDefault(); zoomInBtn.click(); }
    if (e.key === "-" || e.key === "_") { e.preventDefault(); zoomOutBtn.click(); }
    if (e.key === "0" || e.key.toLowerCase() === "r") { e.preventDefault(); resetBtn.click(); }
    if (e.key.toLowerCase() === "g") { e.preventDefault(); runGlowSweep(); }
  });

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Error overlay actions
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  retryLoadBtn.addEventListener("click", () => {
    const deck = DECKS[activeIndex];
    loadDeckSvg(deck, { intro: false });
  });

  copyPathBtn.addEventListener("click", async () => {
    const p = errorOverlay.dataset.path || (DECKS[activeIndex]?.svg || "");
    if (!p) return;
    const ok = await copyText(p);
    if (ok){
      errorTitle.textContent = "Copied";
      errorDesc.textContent = `SVG path copied: ${p}`;
      setTimeout(() => {
        errorTitle.textContent = "Deck failed to load";
        errorDesc.textContent = `We couldnâ€™t load the SVG for this deck. Check the file path and try again.`;
      }, 1200);
    }
  });

  goPrevDeckBtn.addEventListener("click", () => prevDeck());
  goNextDeckBtn.addEventListener("click", () => nextDeck());

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Resize
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  let resizeT = 0;
  window.addEventListener("resize", () => {
    clearTimeout(resizeT);
    resizeT = setTimeout(() => {
      // Preserve current center in local coordinates
      const { cx, cy } = getFrameCenterClient();
      const localX = (cx - cx - tx) / scale; // simplifies to -tx/scale
      const localY = (cy - cy - ty) / scale; // simplifies to -ty/scale

      fitScale = computeFitScale();

      // keep the same local center point but clamp and fit if scale is tiny
      if (scale < fitScale * 0.9) scale = fitScale;

      tx = -localX * scale;
      ty = -localY * scale;

      clampPan();
      applyTransform();

      // Re-render hotspots based on new base sizes (baseDeckW/H are for scale=1)
      // Re-measure quickly by temporarily setting scale=1 at center, then restore.
      withNoTransition(() => {
        const prev = { scale, tx, ty };
        scale = 1; tx = 0; ty = 0;
        applyTransform();
        const r = deckObj.getBoundingClientRect();
        baseDeckW = Math.max(200, r.width || baseDeckW);
        baseDeckH = Math.max(200, r.height || baseDeckH);
        scale = prev.scale; tx = prev.tx; ty = prev.ty;
        applyTransform();
      });

      renderHotspots(DECKS[activeIndex]);
    }, 120);
  });

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Init
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  function init(){
    buildCarousel();
    const deck = DECKS[activeIndex];
    setHeader(deck);
    resetToFit(false);
    runGlowSweep();

    // First load uses intro once
    loadDeckSvg(deck, { intro: true }).catch((e) => {
      console.error(e);
      showError("Unexpected error while loading this deck.", deck.svg);
    });
  }

  init();

})();
</script>

</body>
</html>
