<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
<meta name="theme-color" content="#0A2E4A" />

<title>Deck Navigator ¬∑ Adventure of the Seas</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">

<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { height: 100%; }

  :root{
    --navy:#0A2E4A;
    --navy2:#083452;
    --blue:#0F4F76;
    --aqua:#00B4D8;
    --teal:#2DD4BF;
    --sun:#FFB703;
    --coral:#FF6B6B;
    --sand:#F6F1E6;
    --glass: rgba(8, 52, 82, .55);
    --glass2: rgba(10, 46, 74, .62);
    --stroke: rgba(255,255,255,.14);
    --shadow: rgba(0,0,0,.55);
  }

  body{
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    color: #fff;
    overflow: hidden;
    background: radial-gradient(1200px 800px at 18% 18%, rgba(0,180,216,.28), transparent 55%),
                radial-gradient(1200px 800px at 80% 70%, rgba(255,183,3,.22), transparent 60%),
                linear-gradient(180deg, var(--navy2), var(--navy));
  }

  /* Subtle ‚Äúocean light‚Äù motion */
  body::before{
    content:"";
    position: fixed;
    inset:-25%;
    background:
      radial-gradient(circle at 22% 32%, rgba(0,180,216,.35), transparent 58%),
      radial-gradient(circle at 75% 75%, rgba(255,183,3,.25), transparent 62%),
      radial-gradient(circle at 55% 15%, rgba(45,212,191,.16), transparent 60%);
    filter: blur(2px);
    opacity: .9;
    animation: oceanFloat 18s ease-in-out infinite alternate;
    pointer-events:none;
    z-index: 0;
  }

  @keyframes oceanFloat{
    0% { transform: translate3d(0,-1.2%,0) scale(1); }
    100% { transform: translate3d(0,1.2%,0) scale(1.02); }
  }

  header{
    position: relative;
    z-index: 10;
    padding: 18px 18px 14px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: linear-gradient(90deg, rgba(11,66,102,.95), rgba(10,46,74,.95));
    box-shadow: 0 18px 40px rgba(0,0,0,.35);
  }

  .brand{
    display:flex;
    flex-direction: column;
    gap: 4px;
  }

  .brand .kicker{
    letter-spacing: .18em;
    text-transform: uppercase;
    font-size: .78rem;
    opacity: .85;
  }

  .brand .title{
    font-size: 1.35rem;
    font-weight: 800;
    letter-spacing: .2px;
  }

  .brand .subtitle{
    font-size: .95rem;
    font-weight: 600;
    opacity: .9;
  }

  .back{
    color: var(--sun);
    text-decoration: none;
    font-weight: 700;
    background: rgba(255,183,3,.12);
    border: 1px solid rgba(255,183,3,.28);
    padding: 10px 14px;
    border-radius: 999px;
    transition: .2s ease;
    white-space: nowrap;
  }
  .back:active{ transform: scale(.98); }
  .back:hover{ background: rgba(255,183,3,.18); }

  .main{
    position: relative;
    z-index: 2;
    height: calc(100vh - 88px);
    display: grid;
    grid-template-rows: 1fr auto;
    overflow: hidden;
  }

  /* Stage */
  .viewer{
    position: relative;
    overflow: hidden;
    display:flex;
    align-items:center;
    justify-content:center;
    padding: 14px 14px 90px;
  }

  .frame{
    position: relative;
    border-radius: 28px;
    padding: 10px;
    background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
    border: 1px solid rgba(255,255,255,.14);
    box-shadow: 0 30px 70px rgba(0,0,0,.55);
    max-width: min(980px, calc(100vw - 22px));
    width: 100%;
    height: 100%;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow: hidden;
  }

  /* ‚ÄúGlow edge lighting around SVG‚Äù */
  .frame::before{
    content:"";
    position:absolute;
    inset:-10px;
    background: radial-gradient(circle at 50% 30%, rgba(0,180,216,.40), transparent 62%),
                radial-gradient(circle at 20% 80%, rgba(255,183,3,.22), transparent 60%);
    opacity:.55;
    filter: blur(12px);
    z-index:0;
    pointer-events:none;
  }

  /* ‚ÄúGlow sweep‚Äù */
  .frame::after{
    content:"";
    position:absolute;
    inset:-40%;
    background: linear-gradient(110deg,
      transparent 35%,
      rgba(255,255,255,.18) 45%,
      rgba(0,180,216,.14) 50%,
      rgba(255,183,3,.10) 55%,
      transparent 65%);
    transform: translateX(-35%) rotate(6deg);
    animation: sweep 5.8s ease-in-out infinite;
    opacity: .9;
    pointer-events:none;
    z-index:1;
    mix-blend-mode: screen;
  }

  @keyframes sweep{
    0% { transform: translateX(-55%) rotate(6deg); opacity:.55; }
    35% { opacity:.9; }
    100% { transform: translateX(55%) rotate(6deg); opacity:.55; }
  }

  /* Movable/zoomable stage */
  .stage{
    position: relative;
    z-index: 2;
    touch-action: none;
    will-change: transform;
    transform-origin: center center;
  }

  object#deckObject{
    display:block;
    width: 100%;
    height: auto;
    background: var(--sand);
    border-radius: 20px;
    box-shadow:
      0 0 0 3px rgba(255,255,255,.14),
      0 18px 55px rgba(0,0,0,.55),
      0 0 90px rgba(0,180,216,.20);
  }

  /* Hotspot overlay */
  .hotspot-layer{
    position:absolute;
    inset: 0;
    pointer-events:none; /* buttons will enable */
    z-index: 3;
  }

  .hotspot{
    position:absolute;
    pointer-events:auto;
    transform: translate(-50%, -50%);
    border: none;
    cursor: pointer;
    padding: 8px 10px;
    border-radius: 999px;
    background: rgba(255,255,255,.92);
    color: #06243a;
    font-weight: 800;
    font-size: 12px;
    letter-spacing: .02em;
    box-shadow: 0 10px 25px rgba(0,0,0,.28);
    display:flex;
    align-items:center;
    gap: 8px;
    max-width: 220px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .hotspot .dot{
    width: 10px;
    height: 10px;
    border-radius: 999px;
    background: radial-gradient(circle at 30% 30%, #fff, var(--aqua));
    box-shadow: 0 0 0 3px rgba(0,180,216,.18);
    flex: 0 0 auto;
  }

  .hotspot:active{ transform: translate(-50%, -50%) scale(.98); }

  /* Zoom panel */
  .controls{
    position: absolute;
    left: 50%;
    bottom: 16px;
    transform: translateX(-50%);
    z-index: 15;
    display:flex;
    align-items:center;
    gap: 12px;
    padding: 10px 12px;
    border-radius: 999px;
    background: linear-gradient(90deg, rgba(0,180,216,.92), rgba(15,79,118,.92));
    border: 1px solid rgba(255,255,255,.18);
    box-shadow: 0 18px 40px rgba(0,0,0,.45);
    backdrop-filter: blur(12px) saturate(150%);
    -webkit-backdrop-filter: blur(12px) saturate(150%);
  }

  .controls button{
    width: 52px;
    height: 52px;
    border-radius: 999px;
    border: none;
    background: rgba(255,255,255,.95);
    color: #0b2a43;
    font-weight: 900;
    font-size: 22px;
    cursor: pointer;
    box-shadow: 0 10px 22px rgba(0,0,0,.22);
    transition: transform .15s ease, background .15s ease;
  }

  .controls button:active{ transform: scale(.94); }
  .controls button:hover{ background: #fff; }

  .controls .label{
    min-width: 78px;
    text-align: center;
    font-weight: 900;
    font-size: 16px;
    letter-spacing: .02em;
    color: #fff;
    text-shadow: 0 1px 0 rgba(0,0,0,.2);
  }

  .controls .reset{
    width: auto;
    padding: 0 16px;
    font-size: 14px;
    letter-spacing: .04em;
    text-transform: uppercase;
  }

  /* Carousel */
  .carousel{
    position: relative;
    z-index: 12;
    padding: 10px 12px 16px;
    background: linear-gradient(180deg, rgba(10,46,74,.0), rgba(10,46,74,.55));
  }

  .strip{
    display:flex;
    gap: 10px;
    overflow-x: auto;
    padding: 8px 6px;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
  }
  .strip::-webkit-scrollbar{ display:none; }

  .card{
    flex: 0 0 auto;
    width: 92px;
    border-radius: 16px;
    border: 1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.08);
    box-shadow: 0 12px 28px rgba(0,0,0,.25);
    overflow:hidden;
    cursor:pointer;
    transition: transform .15s ease, background .15s ease, border-color .15s ease;
  }
  .card:hover{ background: rgba(255,255,255,.12); }
  .card:active{ transform: scale(.98); }

  .thumb{
    height: 74px;
    background: rgba(246,241,230,.92);
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
  }
  .thumb img{
    width: 120%;
    height: 120%;
    object-fit: contain;
    transform: translateY(4px);
  }

  .meta{
    padding: 8px 10px 9px;
    display:flex;
    flex-direction: column;
    gap: 3px;
  }
  .meta .d{
    font-weight: 900;
    font-size: 12px;
    letter-spacing: .08em;
    text-transform: uppercase;
    opacity:.95;
  }
  .meta .t{
    font-weight: 700;
    font-size: 11px;
    opacity:.9;
    white-space: nowrap;
    overflow:hidden;
    text-overflow: ellipsis;
  }

  .card.active{
    border-color: rgba(255,183,3,.55);
    box-shadow: 0 16px 34px rgba(0,0,0,.30), 0 0 0 2px rgba(255,183,3,.22) inset;
  }

  /* Bottom sheet for venue */
  .sheet{
    position: fixed;
    left: 0; right: 0; bottom: -60%;
    z-index: 30;
    background: rgba(255,255,255,.96);
    color: #0b2a43;
    border-top-left-radius: 22px;
    border-top-right-radius: 22px;
    box-shadow: 0 -24px 60px rgba(0,0,0,.35);
    transition: transform .26s cubic-bezier(.2,.9,.2,1);
    transform: translateY(0);
  }

  .sheet.open{ transform: translateY(-60%); }

  .sheet .grab{
    width: 44px;
    height: 5px;
    border-radius: 999px;
    background: rgba(10,46,74,.18);
    margin: 10px auto 8px;
  }

  .sheet .content{
    padding: 10px 18px 18px;
  }

  .sheet h2{
    font-size: 18px;
    font-weight: 900;
    margin-bottom: 6px;
  }

  .sheet p{
    font-size: 14px;
    line-height: 1.35;
    opacity: .92;
    margin-bottom: 12px;
  }

  .sheet .row{
    display:flex;
    gap: 10px;
    flex-wrap: wrap;
  }

  .pill{
    display:inline-flex;
    align-items:center;
    gap: 8px;
    padding: 10px 12px;
    border-radius: 999px;
    border: 1px solid rgba(10,46,74,.14);
    background: rgba(10,46,74,.06);
    font-weight: 800;
    cursor:pointer;
    user-select:none;
  }
  .pill:active{ transform: scale(.98); }

  .scrim{
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.35);
    z-index: 25;
    opacity: 0;
    pointer-events: none;
    transition: opacity .2s ease;
  }
  .scrim.open{
    opacity: 1;
    pointer-events: auto;
  }

  /* Small screens tweaks */
  @media (max-width: 520px){
    header{ padding: 16px 14px 12px; }
    .brand .title{ font-size: 1.2rem; }
    .brand .subtitle{ font-size: .92rem; }
    .back{ padding: 9px 12px; }
    .controls button{ width: 48px; height: 48px; }
    .controls .label{ min-width: 72px; }
  }
</style>
</head>

<body>

<header>
  <div class="brand">
    <div class="kicker">Adventure of the Seas</div>
    <div class="title">Deck Navigator</div>
    <div class="subtitle" id="deckSubtitle">Deck 04 ¬∑ Entertainment</div>
  </div>
  <a class="back" href="index.html">‚Üê Back</a>
</header>

<div class="main">
  <div class="viewer" id="viewer">
    <div class="frame" id="frame">
      <div class="stage" id="stage" aria-label="Deck plan stage">
        <object id="deckObject" type="image/svg+xml" data="decks/deck-04-final.min.svg"></object>
      </div>
      <div class="hotspot-layer" id="hotspotLayer" aria-hidden="true"></div>

      <div class="controls" aria-label="Zoom controls">
        <button id="zoomOut" aria-label="Zoom out">‚àí</button>
        <div class="label" id="zoomLabel">100%</div>
        <button id="zoomIn" aria-label="Zoom in">+</button>
        <button id="resetBtn" class="reset" aria-label="Reset zoom">Reset</button>
      </div>
    </div>
  </div>

  <div class="carousel">
    <div class="strip" id="deckStrip" aria-label="Deck carousel"></div>
  </div>
</div>

<div class="scrim" id="scrim" aria-hidden="true"></div>

<div class="sheet" id="sheet" role="dialog" aria-modal="true" aria-label="Venue details">
  <div class="grab"></div>
  <div class="content">
    <h2 id="sheetTitle">Venue</h2>
    <p id="sheetDesc">Tap a hotspot on the deck to see details. Swipe down or tap outside to close.</p>
    <div class="row">
      <div class="pill" id="pillZoom">üîé Zoom here</div>
      <div class="pill" id="pillCopy">üìã Copy name</div>
      <div class="pill" id="pillClose">‚úï Close</div>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  // -------------------------
  // Deck catalog (edit as needed)
  // -------------------------
  const DECKS = [
    { id: "02", title: "Lower Promenade", file: "decks/deck-02-final.min.svg" },
    { id: "03", title: "Promenade",       file: "decks/deck-03-final.min.svg" },
    { id: "04", title: "Entertainment",   file: "decks/deck-04-final.min.svg" },
    { id: "05", title: "Promenade",       file: "decks/deck-05-final.min.svg" },
    { id: "06", title: "Cabins",          file: "decks/deck-06-final.min.svg" },
    { id: "07", title: "Cabins",          file: "decks/deck-07-final.min.svg" },
    { id: "08", title: "Cabins + Pool",   file: "decks/deck-08-final.min.svg" },
  ];

  const viewer = document.getElementById("viewer");
  const frame = document.getElementById("frame");
  const stage = document.getElementById("stage");
  const deckObject = document.getElementById("deckObject");
  const deckSubtitle = document.getElementById("deckSubtitle");
  const zoomLabel = document.getElementById("zoomLabel");
  const hotspotLayer = document.getElementById("hotspotLayer");

  const zoomInBtn = document.getElementById("zoomIn");
  const zoomOutBtn = document.getElementById("zoomOut");
  const resetBtn = document.getElementById("resetBtn");

  const strip = document.getElementById("deckStrip");

  const scrim = document.getElementById("scrim");
  const sheet = document.getElementById("sheet");
  const sheetTitle = document.getElementById("sheetTitle");
  const sheetDesc = document.getElementById("sheetDesc");
  const pillZoom = document.getElementById("pillZoom");
  const pillCopy = document.getElementById("pillCopy");
  const pillClose = document.getElementById("pillClose");

  // -------------------------
  // State: transform (pan/zoom)
  // -------------------------
  let scale = 1;
  let tx = 0;
  let ty = 0;

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  function applyTransform() {
    stage.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
    zoomLabel.textContent = `${Math.round(scale * 100)}%`;
  }

  // Fit stage into the frame (prefer height fit -> avoids side gutters)
  function fitToViewport({ allowOversize = true } = {}) {
    const frameRect = frame.getBoundingClientRect();
    const objRect = deckObject.getBoundingClientRect();

    // If object not laid out yet, bail
    if (!objRect.width || !objRect.height) return;

    const pad = 18; // visual breathing room inside frame
    const availW = frameRect.width - pad * 2;
    const availH = frameRect.height - pad * 2;

    const rW = availW / objRect.width;
    const rH = availH / objRect.height;

    // Prefer height fit for long ship decks (more wow on load)
    let target = Math.min(rH, rW);

    // Allow slightly bigger than 1 so it feels ‚Äúpresent‚Äù
    if (allowOversize) target = Math.min(target, 1.25);
    else target = Math.min(target, 1.0);

    scale = clamp(target, 0.18, 4);
    tx = 0;
    ty = 0;
    applyTransform();
  }

  // Smooth focus on a point in stage coords (screen px)
  function focusPoint(screenX, screenY, targetScale) {
    targetScale = clamp(targetScale, 0.18, 4);

    // We want that point to land around center of frame
    const frameRect = frame.getBoundingClientRect();
    const cx = frameRect.left + frameRect.width / 2;
    const cy = frameRect.top + frameRect.height / 2;

    // Convert current translate/scale -> compute new translate to place point at center
    // stage screen pos = (point) transformed by translate + scale
    // We treat input screenX/screenY as already in frame-space from hotspot mapping.
    // To move point to center: newT = center - point*newScale
    // But point is in stage-local pixels (after object layout). We'll calculate with layer coordinates.
    const localX = screenX;
    const localY = screenY;

    // local coords are relative to hotspotLayer (frame content). Convert to frame content origin.
    // We'll set translate in px space that stage uses.
    tx = (cx - (frameRect.left + localX)) + tx; // apply relative nudge
    ty = (cy - (frameRect.top + localY)) + ty;

    scale = targetScale;
    applyTransform();
  }

  // -------------------------
  // Carousel rendering
  // -------------------------
  function currentDeckFromUrl() {
    const u = new URL(window.location.href);
    const q = u.searchParams.get("deck");
    return (q || "04").padStart(2, "0");
  }

  let currentDeckId = currentDeckFromUrl();

  function setDeckInUrl(deckId) {
    const u = new URL(window.location.href);
    u.searchParams.set("deck", deckId);
    history.replaceState(null, "", u.toString());
  }

  function renderCarousel() {
    strip.innerHTML = "";
    for (const d of DECKS) {
      const card = document.createElement("div");
      card.className = "card" + (d.id === currentDeckId ? " active" : "");
      card.setAttribute("role", "button");
      card.setAttribute("tabindex", "0");
      card.setAttribute("aria-label", `Deck ${d.id} ¬∑ ${d.title}`);

      card.innerHTML = `
        <div class="thumb"><img alt="" loading="lazy" src="${d.file}"></div>
        <div class="meta">
          <div class="d">Deck ${d.id}</div>
          <div class="t">${escapeHtml(d.title)}</div>
        </div>
      `;

      const go = () => loadDeck(d.id);
      card.addEventListener("click", go);
      card.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") { e.preventDefault(); go(); }
      });

      strip.appendChild(card);
    }
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }

  // -------------------------
  // Deck loading
  // -------------------------
  function deckMeta(deckId) {
    return DECKS.find(d => d.id === deckId) || DECKS.find(d => d.id === "04");
  }

  async function loadDeck(deckId) {
    const d = deckMeta(deckId);
    if (!d) return;

    // close sheet, clear hotspots
    closeSheet();
    hotspotLayer.innerHTML = "";

    currentDeckId = d.id;
    setDeckInUrl(currentDeckId);
    deckSubtitle.textContent = `Deck ${d.id} ¬∑ ${d.title}`;

    // swap SVG
    deckObject.setAttribute("data", d.file);
    renderCarousel();

    // When object loads: fit, then build hotspots, then do intro tour
    deckObject.addEventListener("load", onDeckLoaded, { once: true });
  }

  // -------------------------
  // Hotspot extraction (auto from SVG text)
  // -------------------------
  function buildHotspotsFromSvg() {
    hotspotLayer.innerHTML = "";

    const doc = deckObject.contentDocument;
    if (!doc) return;

    const svgEl = doc.querySelector("svg");
    if (!svgEl) return;

    const texts = Array.from(doc.querySelectorAll("text"))
      .filter(t => {
        const s = (t.textContent || "").trim();
        if (!s) return false;
        // filter noise
        if (s.length < 3) return false;
        if (/^(ELEV\.?|ELEVATOR|STAIRS?)$/i.test(s)) return false;
        if (/^\d+$/.test(s)) return false;
        // usually venue labels are uppercase
        const letters = s.replace(/[^A-Z]/g,"").length;
        return letters >= 4;
      });

    // Map a subset: prefer larger text first
    const scored = texts.map(t => {
      let bb;
      try { bb = t.getBBox(); } catch { return null; }
      const area = bb.width * bb.height;
      const label = (t.textContent || "").trim().replace(/\s+/g," ");
      return { t, bb, area, label };
    }).filter(Boolean).sort((a,b) => b.area - a.area);

    // Keep a sane number (avoid clutter)
    const picks = [];
    const seen = new Set();
    for (const item of scored) {
      if (picks.length >= 14) break;
      const key = item.label.toUpperCase();
      if (seen.has(key)) continue;
      seen.add(key);
      picks.push(item);
    }

    // For coordinate conversion: use SVG CTM -> screen -> frame-relative
    const frameRect = frame.getBoundingClientRect();

    for (const item of picks) {
      const { t, bb, label } = item;

      // center of text bbox in SVG coordinates
      const cx = bb.x + bb.width / 2;
      const cy = bb.y + bb.height / 2;

      const pt = svgEl.createSVGPoint();
      pt.x = cx;
      pt.y = cy;

      // transform to screen using element CTM
      const ctm = t.getScreenCTM?.();
      if (!ctm) continue;
      const sp = pt.matrixTransform(ctm);

      // convert to frame coordinates
      const fx = sp.x - frameRect.left;
      const fy = sp.y - frameRect.top;

      // Create button
      const btn = document.createElement("button");
      btn.className = "hotspot";
      btn.type = "button";
      btn.style.left = `${fx}px`;
      btn.style.top = `${fy}px`;
      btn.innerHTML = `<span class="dot"></span><span>${escapeHtml(label)}</span>`;

      btn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        openVenue(label, fx, fy);
      });

      hotspotLayer.appendChild(btn);
    }
  }

  // -------------------------
  // Bottom sheet (venue info)
  // -------------------------
  let activeVenue = null;

  function openVenue(name, fx, fy) {
    activeVenue = { name, fx, fy };

    sheetTitle.textContent = name;
    sheetDesc.textContent = "Tap Zoom here to center this spot. Swipe left/right to switch decks. Pinch to zoom.";

    scrim.classList.add("open");
    sheet.classList.add("open");
  }

  function closeSheet() {
    activeVenue = null;
    scrim.classList.remove("open");
    sheet.classList.remove("open");
  }

  scrim.addEventListener("click", closeSheet);
  pillClose.addEventListener("click", closeSheet);

  pillCopy.addEventListener("click", async () => {
    if (!activeVenue) return;
    try {
      await navigator.clipboard.writeText(activeVenue.name);
      sheetDesc.textContent = "Copied to clipboard ‚úÖ";
      setTimeout(() => {
        if (activeVenue) sheetDesc.textContent = "Tap Zoom here to center this spot. Swipe left/right to switch decks. Pinch to zoom.";
      }, 900);
    } catch {
      sheetDesc.textContent = "Clipboard blocked (iOS sometimes does this). Long-press the name to copy.";
    }
  });

  pillZoom.addEventListener("click", () => {
    if (!activeVenue) return;
    // focus a little tighter than fit
    const target = clamp(Math.max(scale, 1.35), 0.18, 4);
    // Nudge center toward that hotspot
    // Because hotspots already in frame coords, we can compute translate to bring it to mid
    const frameRect = frame.getBoundingClientRect();
    const centerX = frameRect.width / 2;
    const centerY = frameRect.height / 2;

    // Adjust translate so hotspot moves to center
    tx += (centerX - activeVenue.fx);
    ty += (centerY - activeVenue.fy);

    scale = target;
    applyTransform();
  });

  // -------------------------
  // Gesture system: pan / pinch / swipe deck
  // -------------------------
  let dragging = false;
  let panStartX = 0, panStartY = 0;
  let startTx = 0, startTy = 0;

  // swipe detection
  let swipeStartX = 0, swipeStartY = 0, swipeT0 = 0;
  let isPinching = false;
  let pinchStartDist = 0;
  let pinchStartScale = 1;

  function pointerDown(e) {
    dragging = true;
    stage.setPointerCapture?.(e.pointerId);
    panStartX = e.clientX;
    panStartY = e.clientY;
    startTx = tx;
    startTy = ty;

    swipeStartX = e.clientX;
    swipeStartY = e.clientY;
    swipeT0 = performance.now();
  }

  function pointerMove(e) {
    if (!dragging || isPinching) return;
    const dx = e.clientX - panStartX;
    const dy = e.clientY - panStartY;

    tx = startTx + dx;
    ty = startTy + dy;
    applyTransform();
  }

  function pointerUp(e) {
    dragging = false;

    // If it was a horizontal swipe (and not a big vertical drag), switch decks
    const dt = performance.now() - swipeT0;
    const dx = e.clientX - swipeStartX;
    const dy = e.clientY - swipeStartY;

    const absX = Math.abs(dx);
    const absY = Math.abs(dy);

    // avoid triggering while zoomed in and user is panning
    const canSwipe = scale <= 1.35;

    if (canSwipe && dt < 420 && absX > 70 && absX > absY * 1.3) {
      if (dx < 0) nextDeck();
      else prevDeck();
    }
  }

  // touch pinch
  function touchMove(e) {
    if (e.touches.length === 2) {
      isPinching = true;
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const dist = Math.sqrt(dx*dx + dy*dy);

      if (!pinchStartDist) {
        pinchStartDist = dist;
        pinchStartScale = scale;
        return;
      }

      const factor = dist / pinchStartDist;
      const next = clamp(pinchStartScale * factor, 0.18, 4);
      scale = next;
      applyTransform();
    }
  }

  function touchEnd(e) {
    if (e.touches.length < 2) {
      pinchStartDist = 0;
      isPinching = false;
    }
  }

  stage.addEventListener("pointerdown", pointerDown);
  stage.addEventListener("pointermove", pointerMove);
  stage.addEventListener("pointerup", pointerUp);
  stage.addEventListener("pointercancel", () => dragging = false);

  stage.addEventListener("touchmove", touchMove, { passive: true });
  stage.addEventListener("touchend", touchEnd, { passive: true });
  stage.addEventListener("touchcancel", touchEnd, { passive: true });

  // buttons
  zoomInBtn.addEventListener("click", () => {
    scale = clamp(scale + 0.18, 0.18, 4);
    applyTransform();
  });

  zoomOutBtn.addEventListener("click", () => {
    scale = clamp(scale - 0.18, 0.18, 4);
    applyTransform();
  });

  resetBtn.addEventListener("click", () => {
    fitToViewport({ allowOversize: true });
  });

  // -------------------------
  // Deck switching (swipe & carousel)
  // -------------------------
  function deckIndex(id) {
    return Math.max(0, DECKS.findIndex(d => d.id === id));
  }

  function nextDeck() {
    const i = deckIndex(currentDeckId);
    const n = (i + 1) % DECKS.length;
    loadDeck(DECKS[n].id);
  }

  function prevDeck() {
    const i = deckIndex(currentDeckId);
    const p = (i - 1 + DECKS.length) % DECKS.length;
    loadDeck(DECKS[p].id);
  }

  // -------------------------
  // Intro tour animation (auto-scroll)
  // -------------------------
  function runIntroTour() {
    // Only do the tour if user hasn't interacted recently
    let cancelled = false;

    const cancel = () => { cancelled = true; };
    stage.addEventListener("pointerdown", cancel, { once: true });
    stage.addEventListener("touchstart", cancel, { once: true });

    // Start with fit
    fitToViewport({ allowOversize: true });

    // Simple ‚Äúguided glance‚Äù:
    // 1) slight zoom in
    // 2) gentle pan down
    // 3) settle back to fit
    const frameRect = frame.getBoundingClientRect();

    const steps = [
      { t: 200,  s: Math.min(scale * 1.08, 1.35), dx: 0,  dy: -18 },
      { t: 1100, s: Math.min(scale * 1.12, 1.45), dx: 0,  dy: 140 },
      { t: 2100, s: scale,                      dx: 0,  dy: 0 },
    ];

    const startScale = scale;
    const startTx0 = tx;
    const startTy0 = ty;

    const t0 = performance.now();

    function lerp(a,b,p){ return a + (b-a)*p; }
    function ease(p){ return 1 - Math.pow(1-p, 3); }

    function animate(now){
      if (cancelled) return;

      const elapsed = now - t0;
      let prev = { t: 0, s: startScale, dx: 0, dy: 0 };
      let next = steps[0];

      for (let i=0; i<steps.length; i++){
        if (elapsed <= steps[i].t) { next = steps[i]; break; }
        prev = steps[i];
        next = steps[Math.min(i+1, steps.length-1)];
      }

      const seg = Math.max(1, next.t - prev.t);
      const p = clamp((elapsed - prev.t) / seg, 0, 1);
      const ep = ease(p);

      const s = lerp(prev.s, next.s, ep);
      const dx = lerp(prev.dx, next.dx, ep);
      const dy = lerp(prev.dy, next.dy, ep);

      scale = s;
      tx = startTx0 + dx;
      ty = startTy0 + dy;
      applyTransform();

      if (elapsed < steps[steps.length-1].t + 80) requestAnimationFrame(animate);
      else {
        // final settle: refit in case layout changed
        fitToViewport({ allowOversize: true });
      }
    }

    requestAnimationFrame(animate);
  }

  // -------------------------
  // On deck load
  // -------------------------
  function onDeckLoaded() {
    // Layout settle
    setTimeout(() => {
      fitToViewport({ allowOversize: true });
      buildHotspotsFromSvg();
      runIntroTour();
    }, 80);
  }

  // -------------------------
  // Init
  // -------------------------
  renderCarousel();
  loadDeck(currentDeckId);

  // improve initial fit if object takes time
  window.addEventListener("resize", () => fitToViewport({ allowOversize: true }));

})();
</script>

</body>
</html>