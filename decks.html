<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=5.0">
  <title>Deck Navigator Â· Adventure of the Seas</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Plus+Jakarta+Sans:wght@700;800;900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <style>
    /* â”€â”€ Reset & Base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --navy:    #0a2e4a;
      --navy2:   #083452;
      --blue:    #0f4f76;
      --accent:  #00b4e6;
      --gold:    #ffd740;
      --gold2:   #c6a15b;
      --white:   #ffffff;
      --bg:      #f0f6fb;
      --bg2:     #e4eff8;
      --card-bg: #ffffff;
      --text:    #0d2236;
      --muted:   #5a7a93;
      --radius:  22px;
      --shadow:  0 8px 32px rgba(10,46,74,.13);
      --shadow-lg: 0 20px 60px rgba(10,46,74,.22);
      --stage-bg-1: #071e33;
      --stage-bg-2: #103a60;
      --glow: rgba(0,180,230,.55);
      --glow2: rgba(255,215,64,.35);
      --canvas-pad: 18px;
      --min-zoom: .65;
      --max-zoom: 6;
    }

    html { scroll-behavior: smooth; }

    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .site-header {
      background: linear-gradient(135deg, var(--navy) 0%, var(--navy2) 100%);
      padding: 0 1.5rem;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 2px 20px rgba(0,0,0,.3);
    }

    .header-inner {
      max-width: 1200px;
      margin: auto;
      height: 62px;
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .header-brand {
      display: flex;
      align-items: center;
      gap: .6rem;
      text-decoration: none;
      color: var(--white);
    }

    .header-brand i {
      color: var(--gold);
      font-size: 1.2rem;
    }

    .header-brand-text { line-height: 1.2; }

    .header-brand-title {
      font-family: 'Plus Jakarta Sans', sans-serif;
      font-weight: 800;
      font-size: .95rem;
      color: var(--white);
      display: block;
    }

    .header-brand-sub {
      font-size: .7rem;
      color: rgba(255,255,255,.55);
      display: block;
    }

    .header-spacer { flex: 1; }

    .header-badge {
      background: rgba(255,215,64,.15);
      border: 1px solid rgba(255,215,64,.3);
      color: var(--gold);
      font-size: .72rem;
      font-weight: 700;
      padding: .3rem .75rem;
      border-radius: 999px;
      white-space: nowrap;
    }

    /* â”€â”€ Hero â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .hero {
      background: linear-gradient(160deg, var(--navy) 0%, #0d3f60 60%, #0f5580 100%);
      padding: 3.5rem 1.5rem 3rem;
      text-align: center;
      position: relative;
      overflow: hidden;
    }

    .hero::before {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse at 70% 0%, rgba(0,180,230,.18) 0%, transparent 60%),
                  radial-gradient(ellipse at 20% 100%, rgba(255,215,64,.1) 0%, transparent 50%);
      pointer-events: none;
    }

    .hero-badge {
      display: inline-flex;
      align-items: center;
      gap: .5rem;
      background: rgba(255,255,255,.1);
      border: 1px solid rgba(255,255,255,.2);
      color: rgba(255,255,255,.9);
      font-size: .78rem;
      font-weight: 600;
      padding: .4rem 1rem;
      border-radius: 999px;
      margin-bottom: 1.25rem;
    }

    .hero-badge i { color: var(--gold); }

    .hero h1 {
      font-family: 'Plus Jakarta Sans', sans-serif;
      font-weight: 900;
      font-size: clamp(2rem, 5vw, 3rem);
      color: var(--white);
      margin-bottom: .75rem;
      line-height: 1.1;
    }

    .hero h1 em {
      color: var(--accent);
      font-style: normal;
    }

    .hero-sub {
      color: rgba(255,255,255,.65);
      font-size: .95rem;
      max-width: 480px;
      margin: 0 auto 2rem;
      line-height: 1.6;
    }

    /* â”€â”€ Search â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .search-wrap {
      display: flex;
      align-items: center;
      max-width: 420px;
      margin: 0 auto;
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.22);
      border-radius: 999px;
      padding: .2rem .2rem .2rem 1.1rem;
      backdrop-filter: blur(8px);
      transition: .2s;
    }

    .search-wrap:focus-within {
      background: rgba(255,255,255,.18);
      border-color: rgba(0,180,230,.7);
      box-shadow: 0 0 0 3px rgba(0,180,230,.2);
    }

    .search-wrap i {
      color: rgba(255,255,255,.55);
      font-size: .85rem;
      margin-right: .5rem;
      flex-shrink: 0;
    }

    .search-wrap input {
      flex: 1;
      background: none;
      border: none;
      outline: none;
      color: var(--white);
      font-size: .92rem;
      font-family: inherit;
      min-width: 0;
    }

    .search-wrap input::placeholder { color: rgba(255,255,255,.45); }

    .search-wrap button {
      background: rgba(255,255,255,.15);
      border: none;
      color: var(--white);
      width: 34px;
      height: 34px;
      border-radius: 50%;
      cursor: pointer;
      flex-shrink: 0;
      transition: .2s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: .8rem;
    }

    .search-wrap button:hover { background: rgba(255,255,255,.28); }

    /* â”€â”€ Grid Section â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .grid-section {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2.5rem 1.25rem 5rem;
    }

    .grid-meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1.25rem;
    }

    .grid-meta h2 {
      font-family: 'Plus Jakarta Sans', sans-serif;
      font-weight: 800;
      font-size: 1.15rem;
      color: var(--navy);
    }

    .grid-count {
      font-size: .8rem;
      color: var(--muted);
      font-weight: 600;
      background: var(--bg2);
      padding: .3rem .8rem;
      border-radius: 999px;
    }

    .deck-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 1.1rem;
    }

    /* â”€â”€ Deck Card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .deck-card {
      background: var(--card-bg);
      border-radius: var(--radius);
      padding: 1.5rem 1.25rem 1.25rem;
      cursor: pointer;
      box-shadow: var(--shadow);
      border: 1.5px solid transparent;
      transition: transform .22s ease, box-shadow .22s ease, border-color .22s ease;
      position: relative;
      overflow: hidden;
      user-select: none;
    }

    .deck-card::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--accent), var(--gold));
      opacity: 0;
      transition: opacity .22s;
    }

    .deck-card:hover {
      transform: translateY(-5px);
      box-shadow: var(--shadow-lg);
      border-color: rgba(0,180,230,.25);
    }

    .deck-card:hover::before { opacity: 1; }

    .deck-card:active { transform: translateY(-2px) scale(.99); }

    .card-num {
      font-family: 'Plus Jakarta Sans', sans-serif;
      font-weight: 900;
      font-size: 2.2rem;
      color: var(--accent);
      line-height: 1;
      margin-bottom: .3rem;
    }

    .card-name {
      font-weight: 700;
      font-size: .95rem;
      color: var(--navy);
      margin-bottom: .35rem;
    }

    .card-hint {
      font-size: .75rem;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: .35rem;
    }

    .card-hint i { font-size: .65rem; }

    .card-arrow {
      position: absolute;
      right: 1.1rem;
      bottom: 1.1rem;
      width: 30px;
      height: 30px;
      background: var(--bg);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--accent);
      font-size: .7rem;
      transition: .2s;
    }

    .deck-card:hover .card-arrow {
      background: var(--accent);
      color: var(--white);
    }

    /* â”€â”€ Empty State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .empty-state {
      text-align: center;
      padding: 4rem 1rem;
      color: var(--muted);
      grid-column: 1 / -1;
    }

    .empty-state i { font-size: 2.5rem; margin-bottom: 1rem; opacity: .4; display: block; }

    /* â”€â”€ Modal Backdrop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(5,18,35,.88);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: env(safe-area-inset-top, 1rem) 1rem env(safe-area-inset-bottom, 1rem);
      opacity: 0;
      pointer-events: none;
      transition: opacity .25s ease;
    }

    .modal-backdrop.is-open {
      opacity: 1;
      pointer-events: auto;
    }

    /* â”€â”€ Modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .modal {
      background: #fff;
      border-radius: 28px;
      width: min(98%, 1100px);
      max-height: calc(100vh - 2rem);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 30px 80px rgba(0,0,0,.45);
      transform: scale(.96) translateY(12px);
      transition: transform .28s cubic-bezier(.22,.61,.36,1);
    }

    .modal-backdrop.is-open .modal {
      transform: scale(1) translateY(0);
    }

    /* â”€â”€ Modal Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .modal-header {
      background: linear-gradient(135deg, var(--navy) 0%, var(--blue) 100%);
      padding: 1.25rem 1.5rem;
      display: flex;
      align-items: center;
      gap: 1rem;
      flex-shrink: 0;
    }

    .modal-header-info { flex: 1; min-width: 0; }

    .modal-deck-num {
      font-family: 'Plus Jakarta Sans', sans-serif;
      font-weight: 900;
      font-size: 1.9rem;
      color: var(--accent);
      line-height: 1;
    }

    .modal-deck-name {
      font-size: .85rem;
      color: rgba(255,255,255,.7);
      margin-top: .1rem;
    }

    .modal-nav {
      display: flex;
      gap: .5rem;
    }

    .modal-nav-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 1.5px solid rgba(255,255,255,.25);
      background: rgba(255,255,255,.1);
      color: var(--white);
      cursor: pointer;
      transition: .2s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: .85rem;
    }

    .modal-nav-btn:hover { background: rgba(255,255,255,.25); }
    .modal-nav-btn:disabled { opacity: .3; cursor: default; }

    .modal-close {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 1.5px solid rgba(255,255,255,.25);
      background: rgba(255,255,255,.1);
      color: var(--white);
      cursor: pointer;
      transition: .2s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: .9rem;
      flex-shrink: 0;
    }

    .modal-close:hover { background: rgba(220,60,60,.5); border-color: rgba(220,60,60,.6); }

    /* â”€â”€ Plan Viewer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .plan-viewer {
      flex: 1;
      overflow: hidden;
      position: relative;
      background: radial-gradient(circle at center, var(--stage-bg-2), var(--stage-bg-1));
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 320px;
    }

    .plan-viewer::before,
    .plan-viewer::after {
      content:'';
      position:absolute;
      inset:-40%;
      pointer-events:none;
      opacity:.55;
      background:
        radial-gradient(circle at 30% 20%, rgba(0,180,230,.16) 0%, transparent 48%),
        radial-gradient(circle at 70% 30%, rgba(255,215,64,.10) 0%, transparent 52%),
        radial-gradient(circle at 50% 70%, rgba(0,180,230,.10) 0%, transparent 55%);
      filter: blur(16px);
      transform: translate3d(0,0,0);
      animation: driftA 18s ease-in-out infinite;
    }
    .plan-viewer::after {
      opacity:.35;
      filter: blur(22px);
      animation: driftB 26s ease-in-out infinite reverse;
    }
    @keyframes driftA {
      0%{transform: translate3d(-1.5%, -1.5%, 0) scale(1.02) rotate(0.4deg);}
      50%{transform: translate3d(1.8%, 1.2%, 0) scale(1.06) rotate(-0.3deg);}
      100%{transform: translate3d(-1.5%, -1.5%, 0) scale(1.02) rotate(0.4deg);}
    }
    @keyframes driftB {
      0%{transform: translate3d(1.2%, -1.4%, 0) scale(1.08) rotate(-0.5deg);}
      50%{transform: translate3d(-1.6%, 1.3%, 0) scale(1.02) rotate(0.35deg);}
      100%{transform: translate3d(1.2%, -1.4%, 0) scale(1.08) rotate(-0.5deg);}
    }

    .plan-stage {
      position: relative;
      width: 100%;
      height: 100%;
      cursor: grab;
      touch-action: none;
      user-select: none;
      overflow: hidden;
      padding: var(--canvas-pad);
      z-index: 1;
    }
    .plan-stage:active { cursor: grabbing; }

    .plan-frame {
      position: absolute;
      inset: var(--canvas-pad);
      border-radius: 14px;
      pointer-events: none;
      box-shadow:
        0 0 0 1px rgba(255,255,255,.08) inset,
        0 0 0 1px rgba(0,0,0,.22),
        0 18px 60px rgba(0,0,0,.35);
    }

    .plan-frame::before {
      content:'';
      position:absolute;
      inset:-2px;
      border-radius: 16px;
      background: linear-gradient(135deg, var(--glow), var(--glow2));
      opacity:.28;
      filter: blur(10px);
    }

    .plan-canvas {
      position: absolute;
      inset: var(--canvas-pad);
      display: grid;
      place-items: center;
      transform: translate3d(0,0,0);
      will-change: transform;
    }

    .plan-content {
      transform-origin: 0 0;
      will-change: transform;
      filter: drop-shadow(0 18px 26px rgba(0,0,0,.25));
    }

    .plan-content svg {
      display: block;
      width: auto;
      height: auto;
      max-width: none;
      max-height: none;
    }

    .plan-content svg * { shape-rendering: geometricPrecision; }

    .plan-loader {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      color: rgba(255,255,255,.75);
      font-size: .9rem;
      z-index: 3;
    }

    .spinner {
      width: 36px;
      height: 36px;
      border: 3px solid rgba(255,255,255,.15);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin .8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .plan-error {
      position: absolute;
      inset: 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: .75rem;
      color: rgba(255,255,255,.65);
      text-align: center;
      padding: 2rem;
      z-index: 3;
    }

    .plan-error i { font-size: 2.5rem; opacity: .5; }
    .plan-error p { font-size: .85rem; line-height: 1.6; }

    .plan-fallback {
      position: absolute;
      inset: 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      color: rgba(255,255,255,.8);
      text-align: center;
      padding: 2rem;
      z-index: 3;
    }

    .viewer-hint {
      position: absolute;
      left: 14px;
      bottom: 14px;
      display: inline-flex;
      align-items: center;
      gap: .5rem;
      padding: .55rem .75rem;
      border-radius: 999px;
      background: rgba(5,18,35,.45);
      border: 1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.85);
      font-size: .78rem;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 2;
      opacity: .95;
    }
    .viewer-hint i { color: var(--gold); }
    .viewer-hint kbd {
      font: inherit;
      font-weight: 800;
      padding: .12rem .4rem;
      border-radius: 7px;
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.18);
    }

    /* â”€â”€ Zoom Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .zoom-bar {
      background: #f0f6fb;
      border-top: 1px solid rgba(0,0,0,.07);
      padding: .75rem 1.25rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: .6rem;
      flex-shrink: 0;
    }

    .zoom-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 1.5px solid rgba(0,0,0,.1);
      background: var(--white);
      color: var(--navy);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: .8rem;
      box-shadow: 0 2px 8px rgba(0,0,0,.08);
      transition: .18s;
    }

    .zoom-btn:hover { background: var(--accent); color: var(--white); border-color: var(--accent); }

    .zoom-label {
      font-size: .82rem;
      font-weight: 800;
      color: var(--navy);
      min-width: 64px;
      text-align: center;
    }

    .zoom-divider {
      width: 1px;
      height: 20px;
      background: rgba(0,0,0,.1);
      margin: 0 .2rem;
    }

    @media (max-width: 600px) {
      .hero { padding: 2.5rem 1rem 2rem; }
      .modal { border-radius: 20px 20px 0 0; width: 100%; max-height: 92vh; margin-top: auto; }
      .modal-backdrop { align-items: flex-end; padding: 0; }
      .deck-grid { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: .75rem; }
      .card-num { font-size: 1.8rem; }
      .modal-header { padding: 1rem 1.1rem; }
      .modal-deck-num { font-size: 1.5rem; }
      .viewer-hint { left: 10px; bottom: 10px; font-size: .74rem; }
    }

    @media (prefers-reduced-motion: reduce) {
      .plan-viewer::before,
      .plan-viewer::after { animation: none !important; }
      .modal { transition: none !important; }
    }
  </style>
</head>

<body>

<header class="site-header">
  <div class="header-inner">
    <a href="#" class="header-brand">
      <i class="fas fa-crown"></i>
      <div class="header-brand-text">
        <span class="header-brand-title">Royal Caribbean</span>
        <span class="header-brand-sub">Adventure of the Seas</span>
      </div>
    </a>
    <div class="header-spacer"></div>
    <span class="header-badge"><i class="fas fa-calendar-alt" style="margin-right:.4rem"></i>Feb 14â€“20, 2026</span>
  </div>
</header>

<section class="hero">
  <div class="hero-badge">
    <i class="fas fa-ship"></i>
    Adventure of the Seas Â· 13 Decks
  </div>
  <h1>Explore Every <em>Deck</em></h1>
  <p class="hero-sub">Find staterooms, restaurants, pools, and amenities across every level of the ship.</p>

  <div class="search-wrap">
    <i class="fas fa-search"></i>
    <input id="searchInput" type="search" placeholder="Search decksâ€¦" autocomplete="off" aria-label="Search decks">
    <button id="searchClear" hidden aria-label="Clear search"><i class="fas fa-times"></i></button>
  </div>
</section>

<section class="grid-section">
  <div class="grid-meta">
    <h2>Deck Plans</h2>
    <span id="gridCount" class="grid-count">14 of 14</span>
  </div>
  <div id="deckGrid" class="deck-grid"></div>
</section>

<div id="modalBackdrop" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="modalDeckName">
  <div class="modal">

    <header class="modal-header">
      <div class="modal-header-info">
        <div id="modalDeckNum" class="modal-deck-num"></div>
        <div id="modalDeckName" class="modal-deck-name"></div>
      </div>
      <div class="modal-nav">
        <button id="btnPrev" class="modal-nav-btn" aria-label="Previous deck"><i class="fas fa-chevron-left"></i></button>
        <button id="btnNext" class="modal-nav-btn" aria-label="Next deck"><i class="fas fa-chevron-right"></i></button>
      </div>
      <button id="btnClose" class="modal-close" aria-label="Close"><i class="fas fa-times"></i></button>
    </header>

    <div class="plan-viewer">
      <div id="planLoader" class="plan-loader" aria-live="polite">
        <div class="spinner"></div>
        <span>Loading deck planâ€¦</span>
      </div>

      <div id="planError" class="plan-error" aria-live="polite">
        <i class="fas fa-exclamation-triangle"></i>
        <p>Deck plan unavailable.<br>The SVG file may not be uploaded yet.</p>
        <button id="fallbackBtn" class="zoom-btn" style="margin-top: 1rem; background: rgba(255,255,255,.2); color: white; border-color: rgba(255,255,255,.3);">
          <i class="fas fa-paint-brush"></i> Show preview
        </button>
      </div>

      <div id="planStage" class="plan-stage" aria-label="Deck plan viewer">
        <div class="plan-frame" aria-hidden="true"></div>
        <div id="planCanvas" class="plan-canvas" aria-hidden="true">
          <div id="planContent" class="plan-content"></div>
        </div>
        <div class="viewer-hint" aria-hidden="true">
          <i class="fas fa-hand-pointer"></i>
          Drag to pan Â· Pinch/Scroll to zoom Â· Double-tap to zoom
        </div>
      </div>
    </div>

    <div class="zoom-bar">
      <button id="zoomOut" class="zoom-btn" aria-label="Zoom out"><i class="fas fa-minus"></i></button>
      <span id="zoomLabel" class="zoom-label">100%</span>
      <button id="zoomIn" class="zoom-btn" aria-label="Zoom in"><i class="fas fa-plus"></i></button>
      <div class="zoom-divider" aria-hidden="true"></div>
      <button id="zoomFit" class="zoom-btn" aria-label="Fit to screen"><i class="fas fa-expand"></i></button>
      <button id="zoomReset" class="zoom-btn" aria-label="Reset zoom"><i class="fas fa-compress-arrows-alt"></i></button>
    </div>

  </div>
</div>

<script>
(() => {
  'use strict';

  // ===========================================
  // ULTRA VERBOSE LOGGING SETUP
  // ===========================================
  const LOG = {
    info: (...args) => console.log('ðŸ“˜ [INFO]', ...args),
    warn: (...args) => console.warn('âš ï¸ [WARN]', ...args),
    error: (...args) => console.error('âŒ [ERROR]', ...args),
    success: (...args) => console.log('âœ… [SUCCESS]', ...args),
    debug: (...args) => console.log('ðŸ” [DEBUG]', ...args),
    step: (step, ...args) => console.log(`ðŸ“Œ [STEP ${step}]`, ...args)
  };

  LOG.info('Application starting...');
  LOG.warn('This is a debug build with verbose logging');

  // ===========================================
  // CONFIGURATION
  // ===========================================
  const DECKS = [
    {n:15, name: "Deck 15", hint: "Sports Deck"},
    {n:14, name: "Deck 14", hint: "Pool & Solarium"},
    {n:13, name: "Deck 13", hint: "Lido"},
    {n:12, name: "Deck 12", hint: "Cabins"},
    {n:11, name: "Deck 11", hint: "Cabins"},
    {n:10, name: "Deck 10", hint: "Cabins"},
    {n:9,  name: "Deck 9",  hint: "Cabins"},
    {n:8,  name: "Deck 8",  hint: "Cabins"},
    {n:7,  name: "Deck 7",  hint: "Cabins"},
    {n:6,  name: "Deck 6",  hint: "Promenade"},
    {n:5,  name: "Deck 5",  hint: "Dining"},
    {n:4,  name: "Deck 4",  hint: "Entertainment"},
    {n:3,  name: "Deck 3",  hint: "Lobby"},
    {n:2,  name: "Deck 2",  hint: "Medical"}
  ];

  LOG.info(`Loaded ${DECKS.length} deck configurations`);

  const CFG = {
    minZoom: 0.65,
    maxZoom: 6,
    zoomStep: 0.18,
    zoomDbl: 1.65,
    inertiaFriction: 0.92,
    inertiaStop: 0.18,
    svgPaths: {
      patterns: [
        (n) => `decks/deck-${String(n).padStart(2, '0')}-final.min.svg`,
        (n) => `decks/deck-${n}.svg`,
        (n) => `decks/deck${n}.svg`,
        (n) => `decks/Deck_${String(n).padStart(2, '0')}.svg`,
        (n) => `decks/${n}.svg`
      ]
    }
  };

  LOG.debug('Configuration loaded:', CFG);

  // ===========================================
  // STATE
  // ===========================================
  let filtered = [...DECKS];
  let currentIdx = 0;
  let scale = 1;
  let tx = 0;
  let ty = 0;
  let contentW = 800;
  let contentH = 600;

  LOG.debug('Initial state:', { filtered: filtered.length, currentIdx, scale });

  // Pointer handling
  const pointers = new Map();
  let isPanning = false;
  let lastPan = { x: 0, y: 0, t: 0 };
  let velocity = { x: 0, y: 0 };
  let inertiaRaf = 0;
  let pinchInit = null;
  let lastTap = { t: 0, x: 0, y: 0 };

  // ===========================================
  // DOM ELEMENTS
  // ===========================================
  LOG.step('1', 'Getting DOM elements...');
  
  const elements = {
    grid: document.getElementById('deckGrid'),
    gridCount: document.getElementById('gridCount'),
    searchInput: document.getElementById('searchInput'),
    searchClear: document.getElementById('searchClear'),
    backdrop: document.getElementById('modalBackdrop'),
    modalNum: document.getElementById('modalDeckNum'),
    modalName: document.getElementById('modalDeckName'),
    planStage: document.getElementById('planStage'),
    planCanvas: document.getElementById('planCanvas'),
    planContent: document.getElementById('planContent'),
    planLoader: document.getElementById('planLoader'),
    planError: document.getElementById('planError'),
    fallbackBtn: document.getElementById('fallbackBtn'),
    btnClose: document.getElementById('btnClose'),
    btnPrev: document.getElementById('btnPrev'),
    btnNext: document.getElementById('btnNext'),
    zoomIn: document.getElementById('zoomIn'),
    zoomOut: document.getElementById('zoomOut'),
    zoomFit: document.getElementById('zoomFit'),
    zoomReset: document.getElementById('zoomReset'),
    zoomLabel: document.getElementById('zoomLabel')
  };

  // Log which elements were found
  Object.entries(elements).forEach(([key, value]) => {
    if (value) {
      LOG.debug(`Element found: ${key}`);
    } else {
      LOG.warn(`Element missing: ${key}`);
    }
  });

  // Validate required elements
  const required = ['grid', 'gridCount', 'searchInput', 'searchClear', 'backdrop', 'planStage', 'planContent'];
  let missingRequired = false;
  
  for (const key of required) {
    if (!elements[key]) {
      LOG.error(`Missing required element: ${key}`);
      missingRequired = true;
    }
  }
  
  if (missingRequired) {
    LOG.error('Cannot continue - missing required elements');
    return;
  }

  LOG.success('All required DOM elements found');

  // ===========================================
  // UTILITY FUNCTIONS
  // ===========================================
  const clamp = (v, lo, hi) => {
    const result = Math.max(lo, Math.min(hi, v));
    LOG.debug(`Clamping ${v} to [${lo}, ${hi}] = ${result}`);
    return result;
  };
  
  const nowMs = () => {
    const time = performance.now();
    LOG.debug(`Current time: ${time}ms`);
    return time;
  };
  
  const stageRect = () => {
    const rect = elements.planCanvas.getBoundingClientRect();
    LOG.debug('Stage rect:', rect);
    return rect;
  };

  // SVG path resolver
  function findSvgPath(n) {
    LOG.step('2', `Finding SVG path for deck ${n}`);
    for (let i = 0; i < CFG.svgPaths.patterns.length; i++) {
      const pattern = CFG.svgPaths.patterns[i];
      const path = pattern(n);
      LOG.debug(`Pattern ${i + 1}: ${path}`);
    }
    const defaultPath = `decks/deck-${String(n).padStart(2, '0')}.svg`;
    LOG.debug(`Using default path: ${defaultPath}`);
    return defaultPath;
  }

  function svgPath(n) {
    const path = findSvgPath(n);
    const url = new URL(path, document.baseURI).href;
    LOG.debug(`Full SVG URL: ${url}`);
    return url;
  }

  // ===========================================
  // UI STATE MANAGEMENT
  // ===========================================
  function setLoader(loading) {
    LOG.step('3', `Setting loader: ${loading ? 'ON' : 'OFF'}`);
    if (elements.planLoader) {
      elements.planLoader.style.display = loading ? 'flex' : 'none';
      LOG.debug(`Loader display set to: ${elements.planLoader.style.display}`);
    }
    if (elements.planError) {
      elements.planError.style.display = 'none';
    }
  }

  function setError(showFallback = true) {
    LOG.warn('Setting error state', { showFallback });
    if (elements.planLoader) elements.planLoader.style.display = 'none';
    if (elements.planError) {
      elements.planError.style.display = 'flex';
      if (elements.fallbackBtn) {
        elements.fallbackBtn.style.display = showFallback ? 'inline-flex' : 'none';
      }
    }
  }

  function setZoomLabel() {
    if (elements.zoomLabel) {
      elements.zoomLabel.textContent = `${Math.round(scale * 100)}%`;
      LOG.debug(`Zoom label updated: ${elements.zoomLabel.textContent}`);
    }
  }

  function stopInertia() {
    if (inertiaRaf) {
      LOG.debug('Stopping inertia animation');
      cancelAnimationFrame(inertiaRaf);
      inertiaRaf = 0;
    }
  }

  function applyTransform() {
    if (elements.planContent) {
      const transform = `translate3d(${tx}px, ${ty}px, 0) scale(${scale})`;
      elements.planContent.style.transform = transform;
      LOG.debug(`Applied transform: ${transform}`);
      setZoomLabel();
    }
  }

  // ===========================================
  // VIEWPORT CALCULATIONS
  // ===========================================
  function computeFitTransform() {
    LOG.step('4', 'Computing fit transform');
    const r = stageRect();
    const vw = Math.max(1, r.width);
    const vh = Math.max(1, r.height);
    const cw = Math.max(1, contentW);
    const ch = Math.max(1, contentH);

    LOG.debug('Viewport dimensions:', { vw, vh });
    LOG.debug('Content dimensions:', { cw, ch });

    const s = clamp(Math.min(vw / cw, vh / ch), CFG.minZoom, CFG.maxZoom);
    const cx = (vw - cw * s) / 2;
    const cy = (vh - ch * s) / 2;

    LOG.success(`Fit transform computed: scale=${s}, tx=${cx}, ty=${cy}`);
    return { s, x: cx, y: cy };
  }

  function clampToBounds() {
    LOG.step('5', 'Clamping to bounds');
    const r = stageRect();
    const vw = Math.max(1, r.width);
    const vh = Math.max(1, r.height);
    const cw = Math.max(1, contentW * scale);
    const ch = Math.max(1, contentH * scale);
    const margin = Math.min(110, Math.max(28, Math.round(Math.min(vw, vh) * 0.08)));

    LOG.debug('Pre-clamp values:', { tx, ty, scale, cw, ch, vw, vh, margin });

    if (cw <= vw) {
      tx = (vw - cw) / 2;
      LOG.debug('Content fits width, centering');
    } else {
      const minX = vw - cw - margin;
      const maxX = margin;
      tx = clamp(tx, minX, maxX);
      LOG.debug(`Content too wide, clamping X to [${minX}, ${maxX}] = ${tx}`);
    }

    if (ch <= vh) {
      ty = (vh - ch) / 2;
      LOG.debug('Content fits height, centering');
    } else {
      const minY = vh - ch - margin;
      const maxY = margin;
      ty = clamp(ty, minY, maxY);
      LOG.debug(`Content too tall, clamping Y to [${minY}, ${maxY}] = ${ty}`);
    }

    LOG.success('Clamped values:', { tx, ty });
  }

  function zoomAboutScreenPoint(screenX, screenY, newScale) {
    LOG.step('6', `Zooming about screen point (${screenX}, ${screenY}) to scale ${newScale}`);
    const r = stageRect();
    const px = screenX - r.left;
    const py = screenY - r.top;

    LOG.debug('Screen point relative to stage:', { px, py });

    const wx = (px - tx) / scale;
    const wy = (py - ty) / scale;

    LOG.debug('World coordinates:', { wx, wy });

    scale = newScale;
    tx = px - wx * scale;
    ty = py - wy * scale;

    LOG.debug('New transform:', { scale, tx, ty });

    clampToBounds();
    applyTransform();
  }

  function zoomBy(deltaSteps, screenX, screenY) {
    LOG.step('7', `Zooming by ${deltaSteps} steps`);
    const factor = Math.pow(1 + CFG.zoomStep, deltaSteps);
    const newScale = clamp(scale * factor, CFG.minZoom, CFG.maxZoom);
    LOG.debug(`Scale factor: ${factor}, new scale: ${newScale}`);
    zoomAboutScreenPoint(screenX, screenY, newScale);
  }

  function fitToScreen() {
    LOG.step('8', 'Fitting to screen');
    const fit = computeFitTransform();
    scale = fit.s;
    tx = fit.x;
    ty = fit.y;
    stopInertia();
    applyTransform();
    LOG.success('Fit to screen complete');
  }

  function resetView() {
    LOG.step('9', 'Resetting view');
    fitToScreen();
    if (scale > 1.15) {
      LOG.debug('Scale > 1.15, zooming to 1');
      const r = stageRect();
      zoomAboutScreenPoint(r.left + r.width / 2, r.top + r.height / 2, 1);
    }
  }

  // ===========================================
  // FALLBACK SVG GENERATOR
  // ===========================================
  function generateFallbackSVG(deck) {
    LOG.step('10', `Generating fallback SVG for deck ${deck.n}`);
    const colors = ['#0a2e4a', '#0f4f76', '#00b4e6', '#ffd740', '#c6a15b'];
    const color1 = colors[deck.n % colors.length];
    const color2 = colors[(deck.n + 1) % colors.length];
    
    LOG.debug('Fallback colors:', { color1, color2 });
    
    return `
      <svg viewBox="0 0 800 600" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="grad${deck.n}" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:${color1};stop-opacity:1" />
            <stop offset="100%" style="stop-color:${color2};stop-opacity:1" />
          </linearGradient>
          <pattern id="grid${deck.n}" patternUnits="userSpaceOnUse" width="40" height="40">
            <path d="M 40 0 L 0 0 0 40" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="1"/>
          </pattern>
        </defs>
        <rect width="800" height="600" fill="url(#grad${deck.n})"/>
        <rect width="800" height="600" fill="url(#grid${deck.n})"/>
        
        <!-- Deck Number -->
        <text x="400" y="200" font-family="'Plus Jakarta Sans', sans-serif" font-size="120" 
              font-weight="900" text-anchor="middle" fill="rgba(255,255,255,0.2)">${deck.n}</text>
        
        <!-- Ship Icon -->
        <g transform="translate(400,300)">
          <path d="M-80,0 L-40,-40 L40,-40 L80,0 L40,40 L-40,40 Z" 
                fill="rgba(255,255,255,0.9)" stroke="white" stroke-width="4"/>
          <circle cx="0" cy="0" r="20" fill="${color1}" stroke="white" stroke-width="3"/>
        </g>
        
        <!-- Deck Name -->
        <text x="400" y="400" font-family="'Inter', sans-serif" font-size="32" 
              font-weight="700" text-anchor="middle" fill="white">${deck.name}</text>
        
        <!-- Hint -->
        <text x="400" y="460" font-family="'Inter', sans-serif" font-size="24" 
              font-weight="400" text-anchor="middle" fill="rgba(255,255,255,0.8)">${deck.hint}</text>
        
        <!-- Decorative Elements -->
        <circle cx="100" cy="100" r="40" fill="rgba(255,255,255,0.1)"/>
        <circle cx="700" cy="500" r="60" fill="rgba(255,255,255,0.1)"/>
        
        <!-- Water effect -->
        <path d="M0 550 Q200 530, 400 550 T800 550" stroke="rgba(255,255,255,0.3)" fill="none" stroke-width="3"/>
        <path d="M0 570 Q200 550, 400 570 T800 570" stroke="rgba(255,255,255,0.2)" fill="none" stroke-width="2"/>
      </svg>
    `;
  }

  function loadFallbackSVG() {
    const deck = filtered[currentIdx];
    LOG.warn(`Loading fallback SVG for ${deck.name}`);
    
    const svgText = generateFallbackSVG(deck);
    LOG.debug(`Fallback SVG generated, length: ${svgText.length}`);
    
    const doc = new DOMParser().parseFromString(svgText, 'image/svg+xml');
    const svg = doc.querySelector('svg');
    
    if (!svg) {
      LOG.error('Failed to parse fallback SVG');
      setError(false);
      return;
    }
    
    svg.removeAttribute('width');
    svg.removeAttribute('height');
    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
    svg.setAttribute('aria-label', deck.name);
    svg.setAttribute('role', 'img');
    
    elements.planContent.innerHTML = '';
    elements.planContent.appendChild(svg);
    LOG.success('Fallback SVG appended to DOM');
    
    // Get dimensions from viewBox
    const vb = (svg.getAttribute('viewBox') || '0 0 800 600').split(/\s+/).map(Number);
    if (vb.length === 4) {
      contentW = vb[2];
      contentH = vb[3];
      LOG.debug('Fallback dimensions from viewBox:', { contentW, contentH });
    } else {
      contentW = 800;
      contentH = 600;
      LOG.warn('Using default fallback dimensions');
    }
    
    setLoader(false);
    requestAnimationFrame(() => {
      fitToScreen();
      applyTransform();
      LOG.success('Fallback SVG rendered');
    });
  }

  // ===========================================
  // DECK LOADING
  // ===========================================
  async function loadDeck() {
    const deck = filtered[currentIdx];
    LOG.warn(`========== LOADING DECK ${deck.n} ==========`);
    LOG.info(`Deck details:`, deck);
    
    elements.modalNum.textContent = `Deck ${deck.n}`;
    elements.modalName.textContent = deck.hint;
    updateNavButtons();

    elements.planContent.innerHTML = '';
    LOG.debug('Cleared plan content');
    
    if (elements.planError) elements.planError.style.display = 'none';
    setLoader(true);

    stopInertia();
    pointers.clear();
    isPanning = false;
    pinchInit = null;

    // Try to load real SVG
    const path = svgPath(deck.n);
    LOG.warn(`Fetching SVG from: ${path}`);

    try {
      LOG.step('11', 'Starting fetch operation');
      const response = await fetch(path, { 
        cache: 'no-cache',
        mode: 'cors',
        credentials: 'same-origin'
      });
      
      LOG.info('Fetch response:', {
        status: response.status,
        statusText: response.statusText,
        ok: response.ok,
        url: response.url,
        type: response.type
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status} - ${response.statusText}`);
      }

      const svgText = await response.text();
      LOG.info(`SVG text received, length: ${svgText.length}`);
      LOG.debug('SVG preview (first 200 chars):', svgText.substring(0, 200));
      
      // Validate that it looks like SVG
      if (!svgText.includes('<svg') && !svgText.includes('<SVG')) {
        LOG.error('Response does not contain SVG tag');
        throw new Error('Response does not appear to be an SVG');
      }
      LOG.success('SVG tag found in response');

      const parser = new DOMParser();
      const doc = parser.parseFromString(svgText, 'image/svg+xml');
      LOG.debug('SVG parsed');
      
      // Check for parser errors
      const parserError = doc.querySelector('parsererror');
      if (parserError) {
        LOG.error('Parser error found:', parserError.textContent);
        throw new Error('SVG parsing error: ' + parserError.textContent);
      }

      const svg = doc.querySelector('svg');
      if (!svg) {
        LOG.error('No SVG element found in parsed document');
        throw new Error('No SVG root element found');
      }

      LOG.success('SVG element found');
      LOG.debug('SVG attributes:', Array.from(svg.attributes).map(a => `${a.name}=${a.value}`));

      // Ensure viewBox exists
      if (!svg.getAttribute('viewBox')) {
        LOG.warn('SVG has no viewBox, attempting to create');
        const wAttr = svg.getAttribute('width');
        const hAttr = svg.getAttribute('height');
        const w = wAttr ? parseFloat(String(wAttr).replace(/[^0-9.]/g, '')) : NaN;
        const h = hAttr ? parseFloat(String(hAttr).replace(/[^0-9.]/g, '')) : NaN;
        
        if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0) {
          svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
          LOG.success(`Created viewBox from dimensions: 0 0 ${w} ${h}`);
        } else {
          svg.setAttribute('viewBox', '0 0 800 600');
          LOG.warn('Using default viewBox: 0 0 800 600');
        }
      }

      svg.removeAttribute('width');
      svg.removeAttribute('height');
      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
      svg.setAttribute('aria-label', deck.name);
      svg.setAttribute('role', 'img');

      elements.planContent.innerHTML = '';
      elements.planContent.appendChild(svg);
      LOG.success('SVG appended to DOM');
      LOG.debug('planContent children:', elements.planContent.children.length);

      // Get dimensions
      const vb = (svg.getAttribute('viewBox') || '0 0 800 600').split(/\s+/).map(Number);
      if (vb.length === 4 && vb.every(Number.isFinite)) {
        contentW = vb[2];
        contentH = vb[3];
        LOG.success('Content dimensions from viewBox:', { contentW, contentH });
      } else {
        LOG.warn('Invalid viewBox, falling back to bounding rect');
        await new Promise(r => requestAnimationFrame(() => r()));
        const box = elements.planContent.getBoundingClientRect();
        contentW = Math.max(1, box.width);
        contentH = Math.max(1, box.height);
        LOG.warn('Content dimensions from bounding rect:', { contentW, contentH });
      }

      setLoader(false);
      LOG.info('Loader hidden, applying transform');
      
      requestAnimationFrame(() => {
        fitToScreen();
        applyTransform();
        LOG.success('Transform applied');
        
        // Final visibility check
        setTimeout(() => {
          const svgRect = elements.planContent.getBoundingClientRect();
          const stageRect = elements.planCanvas.getBoundingClientRect();
          LOG.info('Final render check:', {
            svgVisible: svgRect.width > 0 && svgRect.height > 0,
            svgDimensions: { width: svgRect.width, height: svgRect.height },
            stageDimensions: { width: stageRect.width, height: stageRect.height },
            transform: elements.planContent.style.transform,
            contentW,
            contentH,
            scale,
            tx,
            ty
          });
          
          if (svgRect.width === 0 || svgRect.height === 0) {
            LOG.error('SVG has zero dimensions after render!');
          } else {
            LOG.success('âœ… SVG is visible!');
          }
        }, 100);
      });

    } catch (error) {
      LOG.error('Failed to load SVG:', {
        message: error.message,
        stack: error.stack,
        name: error.name
      });
      setError(true);
    }
  }

  // ===========================================
  // GRID RENDERING
  // ===========================================
  function renderGrid(list) {
    LOG.step('12', `Rendering grid with ${list.length} items`);
    filtered = list;
    elements.grid.innerHTML = '';
    elements.gridCount.textContent = `${list.length} of ${DECKS.length}`;

    if (!list.length) {
      LOG.warn('No decks match search, showing empty state');
      elements.grid.innerHTML = `
        <div class="empty-state">
          <i class="fas fa-search"></i>
          <p>No decks match your search.</p>
        </div>
      `;
      return;
    }

    list.forEach((deck, i) => {
      const card = document.createElement('div');
      card.className = 'deck-card';
      card.setAttribute('role', 'button');
      card.setAttribute('tabindex', '0');
      card.setAttribute('aria-label', `Open ${deck.name}`);
      card.innerHTML = `
        <div class="card-num">${deck.n}</div>
        <div class="card-name">${deck.name}</div>
        <div class="card-hint"><i class="fas fa-map-pin"></i>${deck.hint}</div>
        <div class="card-arrow"><i class="fas fa-arrow-right"></i></div>
      `;
      card.addEventListener('click', () => openModal(i));
      card.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          openModal(i);
        }
      });
      elements.grid.appendChild(card);
    });
    
    LOG.success(`Grid rendered with ${list.length} cards`);
  }

  function openModal(idx) {
    LOG.warn(`========== OPENING MODAL FOR DECK ${idx} ==========`);
    currentIdx = idx;
    elements.backdrop.classList.add('is-open');
    document.body.style.overflow = 'hidden';
    LOG.debug('Modal opened, body overflow hidden');
    loadDeck();
  }

  function closeModal() {
    LOG.warn('Closing modal');
    elements.backdrop.classList.remove('is-open');
    document.body.style.overflow = '';
    stopInertia();
    pointers.clear();
    isPanning = false;
    pinchInit = null;
    elements.planContent.innerHTML = '';
    elements.planContent.style.transform = '';
    LOG.debug('Modal closed, state reset');
  }

  function updateNavButtons() {
    if (elements.btnPrev) {
      elements.btnPrev.disabled = currentIdx === 0;
      LOG.debug(`Prev button disabled: ${elements.btnPrev.disabled}`);
    }
    if (elements.btnNext) {
      elements.btnNext.disabled = currentIdx === filtered.length - 1;
      LOG.debug(`Next button disabled: ${elements.btnNext.disabled}`);
    }
  }

  // ===========================================
  // POINTER EVENT HANDLERS
  // ===========================================
  function onPointerDown(e) {
    if (!elements.backdrop.classList.contains('is-open')) return;
    LOG.debug('Pointer down:', { id: e.pointerId, x: e.clientX, y: e.clientY, type: e.pointerType });

    elements.planStage?.setPointerCapture?.(e.pointerId);
    pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    stopInertia();

    if (pointers.size === 1) {
      isPanning = true;
      lastPan = { x: e.clientX, y: e.clientY, t: nowMs() };
      velocity = { x: 0, y: 0 };
      LOG.debug('Starting pan');
    }

    if (pointers.size === 2) {
      const pts = Array.from(pointers.values());
      const d = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      pinchInit = { dist: d, scale };
      isPanning = false;
      LOG.debug('Starting pinch', { distance: d, currentScale: scale });
    }
  }

  function onPointerMove(e) {
    if (!pointers.has(e.pointerId)) return;
    pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    if (pointers.size === 1 && isPanning) {
      const prev = lastPan;
      const t = nowMs();
      const dt = Math.max(1, t - prev.t);
      const dx = e.clientX - prev.x;
      const dy = e.clientY - prev.y;

      tx += dx;
      ty += dy;

      velocity.x = dx / dt;
      velocity.y = dy / dt;

      lastPan = { x: e.clientX, y: e.clientY, t };
      clampToBounds();
      applyTransform();
      
      LOG.debug('Panning:', { dx, dy, velocity: { x: velocity.x, y: velocity.y } });
    }

    if (pointers.size === 2 && pinchInit) {
      const pts = Array.from(pointers.values());
      const d = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      const mid = { 
        x: (pts[0].x + pts[1].x) / 2, 
        y: (pts[0].y + pts[1].y) / 2 
      };

      const ratio = d / Math.max(1, pinchInit.dist);
      const newScale = clamp(pinchInit.scale * ratio, CFG.minZoom, CFG.maxZoom);
      LOG.debug('Pinching:', { distance: d, ratio, newScale });
      zoomAboutScreenPoint(mid.x, mid.y, newScale);
    }
  }

  function onPointerUp(e) {
    if (!pointers.has(e.pointerId)) return;
    LOG.debug('Pointer up:', { id: e.pointerId });
    pointers.delete(e.pointerId);

    if (pointers.size === 0) {
      if (isPanning) {
        LOG.debug('Starting inertia');
        startInertia();
      }
      isPanning = false;
      pinchInit = null;
      elements.planStage?.releasePointerCapture?.(e.pointerId);
      return;
    }

    if (pointers.size === 1) {
      const pt = pointers.values().next().value;
      isPanning = true;
      lastPan = { x: pt.x, y: pt.y, t: nowMs() };
      pinchInit = null;
      LOG.debug('Switched to single pointer, continuing pan');
    }
  }

  function startInertia() {
    stopInertia();
    let lastTick = performance.now();
    
    function tick(now) {
      const dt = Math.min(32, now - lastTick);
      lastTick = now;

      tx += velocity.x * dt;
      ty += velocity.y * dt;

      velocity.x *= Math.pow(CFG.inertiaFriction, dt / 16);
      velocity.y *= Math.pow(CFG.inertiaFriction, dt / 16);

      clampToBounds();
      applyTransform();

      const speed = Math.hypot(velocity.x, velocity.y);
      if (speed < CFG.inertiaStop) {
        LOG.debug('Inertia stopped');
        inertiaRaf = 0;
        return;
      }
      inertiaRaf = requestAnimationFrame(tick);
    }
    LOG.debug('Inertia started');
    inertiaRaf = requestAnimationFrame(tick);
  }

  function onWheel(e) {
    if (!elements.backdrop.classList.contains('is-open')) return;
    e.preventDefault();
    const steps = clamp((-e.deltaY / 120), -3, 3);
    LOG.debug('Wheel zoom:', { deltaY: e.deltaY, steps });
    zoomBy(steps, e.clientX, e.clientY);
  }

  function onDblClick(e) {
    if (!elements.backdrop.classList.contains('is-open')) return;
    LOG.debug('Double click zoom');
    zoomAboutScreenPoint(e.clientX, e.clientY, clamp(scale * CFG.zoomDbl, CFG.minZoom, CFG.maxZoom));
  }

  function onTouchTap(e) {
    if (!(e instanceof PointerEvent)) return;
    if (e.pointerType !== 'touch') return;

    const t = nowMs();
    const dt = t - lastTap.t;
    const dx = Math.abs(e.clientX - lastTap.x);
    const dy = Math.abs(e.clientY - lastTap.y);

    lastTap = { t, x: e.clientX, y: e.clientY };

    if (dt < 280 && dx < 26 && dy < 26) {
      LOG.debug('Double tap detected');
      zoomAboutScreenPoint(e.clientX, e.clientY, clamp(scale * CFG.zoomDbl, CFG.minZoom, CFG.maxZoom));
    }
  }

  // ===========================================
  // EVENT LISTENERS
  // ===========================================
  function initEventListeners() {
    LOG.step('13', 'Initializing event listeners');
    
    // Search
    elements.searchInput.addEventListener('input', (e) => {
      const q = String(e.target.value || '').trim().toLowerCase();
      LOG.debug('Search input:', { query: q });
      elements.searchClear.hidden = !q;
      renderGrid(q
        ? DECKS.filter(d =>
            d.name.toLowerCase().includes(q) ||
            String(d.n).includes(q) ||
            (d.hint || '').toLowerCase().includes(q)
          )
        : [...DECKS]
      );
    });

    elements.searchClear.addEventListener('click', () => {
      LOG.debug('Search cleared');
      elements.searchInput.value = '';
      elements.searchClear.hidden = true;
      renderGrid([...DECKS]);
    });

    // Modal controls
    elements.btnClose?.addEventListener('click', closeModal);
    elements.btnPrev?.addEventListener('click', () => {
      if (currentIdx > 0) {
        LOG.debug('Previous deck button clicked');
        currentIdx--;
        loadDeck();
      }
    });
    elements.btnNext?.addEventListener('click', () => {
      if (currentIdx < filtered.length - 1) {
        LOG.debug('Next deck button clicked');
        currentIdx++;
        loadDeck();
      }
    });

    // Fallback button
    elements.fallbackBtn?.addEventListener('click', () => {
      LOG.warn('Fallback button clicked');
      loadFallbackSVG();
    });

    // Zoom controls
    elements.zoomIn?.addEventListener('click', () => {
      LOG.debug('Zoom in clicked');
      const r = stageRect();
      zoomAboutScreenPoint(
        r.left + r.width / 2, 
        r.top + r.height / 2, 
        clamp(scale * (1 + CFG.zoomStep), CFG.minZoom, CFG.maxZoom)
      );
    });
    elements.zoomOut?.addEventListener('click', () => {
      LOG.debug('Zoom out clicked');
      const r = stageRect();
      zoomAboutScreenPoint(
        r.left + r.width / 2, 
        r.top + r.height / 2, 
        clamp(scale / (1 + CFG.zoomStep), CFG.minZoom, CFG.maxZoom)
      );
    });
    elements.zoomFit?.addEventListener('click', () => {
      LOG.debug('Fit to screen clicked');
      fitToScreen();
    });
    elements.zoomReset?.addEventListener('click', () => {
      LOG.debug('Reset zoom clicked');
      resetView();
    });

    // Backdrop click to close
    elements.backdrop.addEventListener('click', (e) => {
      if (e.target === elements.backdrop) {
        LOG.debug('Backdrop clicked, closing modal');
        closeModal();
      }
    });

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (!elements.backdrop.classList.contains('is-open')) return;
      
      LOG.debug('Keyboard event:', { key: e.key });
      switch (e.key) {
        case 'Escape': closeModal(); break;
        case 'ArrowLeft': elements.btnPrev?.click(); break;
        case 'ArrowRight': elements.btnNext?.click(); break;
        case '+':
        case '=': elements.zoomIn?.click(); break;
        case '-':
        case '_': elements.zoomOut?.click(); break;
        case 'f':
        case 'F': elements.zoomFit?.click(); break;
        case 'r':
        case 'R': elements.zoomReset?.click(); break;
      }
    });

    // Pointer events
    elements.planStage.addEventListener('pointerdown', (e) => {
      onTouchTap(e);
      onPointerDown(e);
    });
    elements.planStage.addEventListener('pointermove', onPointerMove);
    elements.planStage.addEventListener('pointerup', onPointerUp);
    elements.planStage.addEventListener('pointercancel', onPointerUp);
    elements.planStage.addEventListener('wheel', onWheel, { passive: false });
    elements.planStage.addEventListener('dblclick', onDblClick);

    // Resize observer
    const ro = new ResizeObserver(() => {
      if (!elements.backdrop.classList.contains('is-open')) return;
      if (!contentW || !contentH) return;
      LOG.debug('Resize observed, reclamping');
      clampToBounds();
      applyTransform();
    });
    ro.observe(elements.planCanvas);
    LOG.success('ResizeObserver attached');

    LOG.success('All event listeners initialized');
  }

  // ===========================================
  // INITIALIZATION
  // ===========================================
  function init() {
    LOG.warn('========== DECK NAVIGATOR INITIALIZING ==========');
    
    // Suppress Eruda errors (browser extension noise)
    const originalConsoleError = console.error;
    console.error = function(...args) {
      if (args[0] && typeof args[0] === 'string' && args[0].includes('Eruda')) {
        return; // Ignore Eruda errors
      }
      originalConsoleError.apply(console, args);
    };
    LOG.info('Eruda errors suppressed');

    // Set up event listeners
    initEventListeners();

    // Initial render
    renderGrid([...DECKS]);

    // Log available paths for debugging
    LOG.info('Available SVG patterns:');
    CFG.svgPaths.patterns.forEach((p, i) => {
      LOG.info(`  Pattern ${i + 1}: ${p(15)}`);
    });

    // Test deck folder accessibility
    fetch('decks/test.svg')
      .then(r => {
        if (r.status === 404) {
          LOG.warn('Decks folder exists but no test.svg found');
        } else {
          LOG.success('Decks folder is accessible');
        }
      })
      .catch(() => {
        LOG.error('Decks folder may not be accessible - check that it exists');
      });

    LOG.success('========== INITIALIZATION COMPLETE ==========');
    LOG.warn('Open a deck to see detailed loading logs');
  }

  // Start the application
  init();
})();
</script>

</body>
</html>