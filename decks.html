<!DOCTYPE html>
<html lang="en" class="app-theme-rcc">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0a2e4a" />
  <title>Deck Navigator · Adventure of the Seas</title>

  <!-- Fonts (weights limited to 800 for Plus Jakarta Sans) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Plus+Jakarta+Sans:wght@800&display=swap" rel="stylesheet">

  <!-- Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>

  <style>
    /* =========================================================
       DECK NAVIGATOR v5.1 — INLINE SVG, ACCESSIBLE, PERFORMANT
       ========================================================= */
    *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
    html{scroll-behavior:smooth}
    body{
      font-family:'Inter',system-ui,-apple-system,sans-serif;
      background:#071a2c;
      color:#fff;
      overflow:hidden;
      -webkit-font-smoothing:antialiased;
      text-rendering:optimizeLegibility;
    }
    a{color:inherit;text-decoration:none}
    button{font:inherit}
    :focus-visible{outline:3px solid #00b4e6; outline-offset:3px; border-radius:14px}
    @media (prefers-reduced-motion: reduce){
      *{animation:none !important; transition:none !important; scroll-behavior:auto !important}
    }

    :root{
      --navy:#0a2e4a;
      --accent:#00b4e6;
      --gold:#ffd740;
      --glass: rgba(255,255,255,.085);
      --glass-brd: rgba(255,255,255,.18);
      --shadow: 0 25px 80px rgba(0,0,0,.45);
      --radius: 22px;
      --ease: cubic-bezier(.22,.61,.36,1);
    }

    /* Background layers */
    #ocean{position:fixed; inset:0; z-index:-4;}
    .sky{
      position:fixed; inset:0; z-index:-3; pointer-events:none;
      background:radial-gradient(ellipse at 50% 18%, rgba(0,180,230,.18), transparent 60%),
                 radial-gradient(ellipse at 18% 86%, rgba(255,215,64,.10), transparent 55%),
                 linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,.55));
    }
    .vignette{
      position:fixed; inset:0; z-index:-2; pointer-events:none;
      background:radial-gradient(ellipse at 50% 20%, rgba(255,255,255,.06), transparent 62%),
                 radial-gradient(ellipse at 50% 100%, rgba(0,0,0,.38), transparent 65%);
    }
    .ship-sil{
      position:fixed; left:50%; bottom:6%; transform:translateX(-50%);
      opacity:.06; font-size:min(320px, 60vw); pointer-events:none; z-index:-1;
      filter: blur(.2px); transition: transform 0.1s linear;
    }

    /* Header */
    header{
      position:sticky; top:0; z-index:100;
      background:rgba(10,46,74,.66); backdrop-filter:blur(14px);
      border-bottom:1px solid rgba(255,255,255,.10);
    }
    .header-inner{
      height:66px; padding:0 1.05rem; display:flex; align-items:center; gap:1rem;
    }
    .titlewrap{display:flex; flex-direction:column; line-height:1.05; min-width:0}
    .title{
      font-family:'Plus Jakarta Sans',sans-serif; font-weight:800;
      letter-spacing:.01em; white-space:nowrap; overflow:hidden;
      text-overflow:ellipsis; max-width:min(62vw, 520px);
    }
    .sub{
      font-size:.75rem; opacity:.75; font-weight:700; white-space:nowrap;
      overflow:hidden; text-overflow:ellipsis; max-width:min(62vw, 520px);
    }
    .spacer{flex:1}

    .pill{
      display:inline-flex; align-items:center; gap:.5rem; padding:.35rem .8rem;
      border-radius:999px; background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.16); color:rgba(255,255,255,.92);
      font-weight:700; font-size:.75rem; user-select:none; white-space:nowrap;
    }
    .pill i{color:var(--gold)}
    .btn{
      display:inline-flex; align-items:center; justify-content:center; gap:.55rem;
      padding:.55rem .9rem; border-radius:999px; background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.16); color:rgba(255,255,255,.92);
      font-weight:700; font-size:.78rem; transition: background .18s var(--ease);
      user-select:none; cursor:pointer;
    }
    .btn:hover{background:rgba(255,255,255,.14); border-color:rgba(0,180,230,.28)}
    .btn:active{transform:translateY(1px)}
    .btn i{color:var(--gold)}
    .primary{
      background: linear-gradient(135deg, #00b4e6, #ffd740);
      color: #0a2e4a; border-color: rgba(255,255,255,.18);
    }

    /* Viewer */
    .viewer{position:fixed; top:66px; left:0; right:0; bottom:0;}
    .frame{
      position:absolute; inset:12px 12px calc(14px + env(safe-area-inset-bottom)) 12px;
      border-radius:24px; background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.16); backdrop-filter:blur(16px);
      box-shadow:var(--shadow); overflow:hidden; touch-action:none;
    }
    .stage{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    }
    .panZoom{
      transform-origin:0 0; will-change:transform; transition:transform 220ms var(--ease);
    }
    /* SVG container: block, no special layout */
    #svgContainer {
      display: block;
    }
    #inlineSvg{
      display: block;
      width: auto;
      height: auto;
      max-width: none;
      max-height: none;
      filter: drop-shadow(0 40px 120px rgba(0,0,0,.55)) drop-shadow(0 0 60px rgba(0,180,230,.20));
      /* TEMPORARY DEBUG: remove this outline after verifying SVG appears */
      outline: 2px solid red;
      background: rgba(255,0,0,0.1);
    }
    .glow{
      pointer-events:none; position:absolute; inset:0; border-radius:24px;
      box-shadow:0 0 0 1px rgba(255,255,255,.06) inset,
                 0 0 40px rgba(0,180,230,.10), 0 0 80px rgba(255,215,64,.06);
    }

    /* Controls */
    .controls{position:absolute; inset:0; pointer-events:none; z-index:50;}
    .zoomStack{
      position:absolute; right:14px; bottom:calc(110px + env(safe-area-inset-bottom));
      display:flex; flex-direction:column; gap:10px; pointer-events:auto; z-index:60;
    }
    .ctrlIconBtn{
      width:50px; height:50px; border-radius:18px; background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.16); backdrop-filter:blur(14px);
      color:#fff; display:grid; place-items:center; box-shadow:0 16px 46px rgba(0,0,0,.22);
      cursor:pointer; transition:background .18s var(--ease);
    }
    .ctrlIconBtn:hover{background:rgba(255,255,255,.14); border-color:rgba(0,180,230,.28)}
    .ctrlIconBtn i{color:var(--gold)}
    .recenter{
      position:absolute; left:14px; bottom:calc(14px + env(safe-area-inset-bottom));
      pointer-events:auto; z-index:60; width:54px; height:54px; border-radius:999px;
      background:rgba(255,255,255,.10); border:1px solid rgba(255,255,255,.16);
      display:grid; place-items:center; box-shadow:0 18px 60px rgba(0,0,0,.30);
      cursor:pointer; opacity:0; transform:scale(.88); transition:opacity .2s var(--ease), transform .2s var(--ease);
    }
    .recenter.show{opacity:1; transform:scale(1)}
    .recenter i{color:var(--gold)}
    .dock{
      position:absolute; left:50%; transform:translateX(-50%);
      bottom:calc(14px + env(safe-area-inset-bottom)); display:flex; align-items:center; gap:10px;
      pointer-events:auto; z-index:60; padding:.45rem .5rem; border-radius:999px;
      background:rgba(0,0,0,.14); border:1px solid rgba(255,255,255,.14);
      backdrop-filter:blur(14px); box-shadow:0 18px 60px rgba(0,0,0,.28);
    }
    .segmented{
      display:flex; border-radius:999px; overflow:hidden; border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.08);
    }
    .segmented button{
      border:none; background:transparent; color:rgba(255,255,255,.92); font-weight:700;
      font-size:.78rem; padding:.55rem .9rem; cursor:pointer; transition:background .18s var(--ease);
      white-space:nowrap;
    }
    .segmented button.active{background:#ffd740; color:#0a2e4a;}
    .zoomReadout{
      display:inline-flex; align-items:center; gap:.5rem; padding:.52rem .75rem;
      border-radius:999px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.14);
      color:#fff; font-weight:700; font-size:.78rem; white-space:nowrap;
    }
    .zoomReadout i{color:var(--gold)}

    /* Modal with focus trap */
    .modal{
      position:fixed; inset:0; background:rgba(0,0,0,.40); backdrop-filter:blur(8px);
      display:none; z-index:3000; padding:16px;
    }
    .modal.show{display:block}
    .modalCard{
      max-width:720px; margin:80px auto 0; background:rgba(255,255,255,.085);
      border:1px solid rgba(255,255,255,.18); border-radius:24px;
      box-shadow:0 30px 110px rgba(0,0,0,.55); overflow:hidden;
    }
    .modalHead{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:14px 16px; background:rgba(10,46,74,.66); border-bottom:1px solid rgba(255,255,255,.10);
    }
    .modalTitle{font-family:'Plus Jakarta Sans',sans-serif; font-weight:800;}
    .modalBody{padding:14px 16px 16px}
    .deckGrid{
      display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:10px;
    }
    @media (min-width:540px){.deckGrid{grid-template-columns:repeat(4,minmax(0,1fr));}}
    .deckTile{
      border-radius:18px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.12);
      padding:12px 10px; display:flex; flex-direction:column; gap:6px; cursor:pointer;
      transition:transform .18s var(--ease), border-color .18s var(--ease), background .18s var(--ease);
      min-height:64px;
    }
    .deckTile:hover{transform:translateY(-1px); border-color:rgba(0,180,230,.28); background:rgba(255,255,255,.10)}
    .deckTile.active{border-color:rgba(255,215,64,.55); box-shadow:0 0 0 1px rgba(255,215,64,.20) inset;}
    .deckNum{font-family:'Plus Jakarta Sans',sans-serif; font-weight:800; font-size:1rem;}
    .deckPath{font-size:.72rem; opacity:.7; font-weight:600; word-break:break-all;}
    .deckStatus{
      font-size:.72rem; font-weight:700; display:flex; gap:.45rem; align-items:center;
    }
    .deckStatus i{color:var(--gold)}
    .deckStatus.missing i{color:#ff6b6b}
    /* focus trap helpers */
    .focus-trap-start, .focus-trap-end { position: absolute; width: 1px; height: 1px; overflow: hidden; opacity: 0; pointer-events: none; }

    /* Overlays */
    .overlay{
      position:absolute; inset:0; display:none; align-items:center; justify-content:center;
      flex-direction:column; gap:.9rem; background:rgba(7,26,44,.78); backdrop-filter:blur(12px);
      z-index:200; text-align:center; padding:18px;
    }
    .overlay.show{display:flex}
    .spinner{
      width:44px; height:44px; border-radius:999px; border:3px solid rgba(255,255,255,.18);
      border-top-color:#00b4e6; animation:spin 1s linear infinite;
    }
    @keyframes spin{to{transform:rotate(360deg)}}
    .overlay h2{font-family:'Plus Jakarta Sans',sans-serif; font-weight:800; font-size:1.1rem;}
    .overlay p{opacity:.9; font-weight:600; max-width:520px;}
    .overlay .small{opacity:.7; font-size:.78rem; word-break:break-all;}

    /* Intro */
    .intro{
      position:fixed; inset:0; z-index:4000; display:none; align-items:center; justify-content:center;
      pointer-events:none; background:radial-gradient(ellipse at 50% 20%, rgba(0,180,230,.22), transparent 60%),
                         linear-gradient(180deg, rgba(7,26,44,.0), rgba(7,26,44,.65));
    }
    .intro.show{display:flex}
    .introCard{
      display:flex; align-items:center; gap:.7rem; padding:.85rem 1.1rem; border-radius:999px;
      background:rgba(10,46,74,.88); border:1px solid rgba(255,255,255,.14);
      box-shadow:0 18px 60px rgba(0,0,0,.35); color:#fff; font-weight:700; font-size:.9rem;
      transform:translateY(6px); opacity:0; animation:introIn 900ms var(--ease) forwards;
    }
    .introCard i{color:var(--gold)}
    .introPulse{
      width:10px; height:10px; border-radius:999px; background:var(--accent);
      box-shadow:0 0 0 0 rgba(0,180,230,.55); animation:pulse 1.1s ease-out infinite;
    }
    @keyframes pulse{0%{box-shadow:0 0 0 0 #00b4e6}100%{box-shadow:0 0 0 18px rgba(0,180,230,0)}}
    @keyframes introIn{0%{opacity:0; transform:translateY(10px)}100%{opacity:1; transform:translateY(0)}}
  </style>
</head>
<body>
  <canvas id="ocean" aria-hidden="true"></canvas>
  <div class="sky" aria-hidden="true"></div>
  <div class="vignette" aria-hidden="true"></div>
  <i class="fas fa-ship ship-sil" aria-hidden="true"></i>

  <div class="intro" id="intro" aria-hidden="true">
    <div class="introCard">
      <span class="introPulse" aria-hidden="true"></span>
      <i class="fas fa-compass" aria-hidden="true"></i>
      <span>Deck Navigator</span>
    </div>
  </div>

  <header>
    <div class="header-inner">
      <div class="titlewrap">
        <div class="title" id="hdrTitle">Deck Navigator</div>
        <div class="sub" id="hdrSub">Adventure of the Seas</div>
      </div>
      <div class="spacer"></div>
      <span class="pill" id="deckPill" title="Active deck">
        <i class="fas fa-layer-group" aria-hidden="true"></i>
        <span id="deckPillText">Deck</span>
      </span>
      <button class="btn primary" id="openDecksBtn" type="button" aria-haspopup="dialog" aria-controls="deckModal">
        <i class="fas fa-layer-group" aria-hidden="true"></i> Decks
      </button>
      <a class="btn" href="index.html" aria-label="Back to dashboard">
        <i class="fas fa-arrow-left" aria-hidden="true"></i> Dashboard
      </a>
    </div>
  </header>

  <div class="viewer" aria-label="Deck navigator">
    <div class="frame" id="frame" aria-label="Deck canvas" tabindex="0">
      <div class="stage" id="stage">
        <div class="panZoom" id="panZoom">
          <!-- Inline SVG injected here -->
          <div id="svgContainer"></div>
        </div>
      </div>
      <div class="glow" aria-hidden="true"></div>

      <!-- Overlays -->
      <div class="overlay" id="loadingOverlay" aria-live="polite">
        <div class="spinner" aria-hidden="true"></div>
        <h2>Loading deck…</h2>
        <p>Pulling the map into focus. Cruise Wi‑Fi is… a vibe.</p>
        <div class="small" id="loadingPath"></div>
      </div>

      <div class="overlay" id="errorOverlay" aria-live="assertive">
        <i class="fas fa-triangle-exclamation fa-2x" style="color:#ff6b6b;" aria-hidden="true"></i>
        <h2>Deck failed to load</h2>
        <p id="errorMsg">We couldn’t load this SVG.</p>
        <div class="small" id="errorPath"></div>
        <div style="display:flex; gap:.6rem; flex-wrap:wrap; justify-content:center; margin-top:.2rem;">
          <button class="btn primary" id="retryBtn" type="button"><i class="fas fa-rotate-right" aria-hidden="true"></i> Retry</button>
          <button class="btn" id="openDecksBtn2" type="button"><i class="fas fa-layer-group" aria-hidden="true"></i> Choose another deck</button>
          <button class="btn" id="dismissErrorBtn" type="button"><i class="fas fa-times" aria-hidden="true"></i> Dismiss</button>
        </div>
      </div>

      <!-- Controls -->
      <div class="controls" aria-hidden="false">
        <div class="zoomStack" role="group" aria-label="Zoom controls">
          <button class="ctrlIconBtn" id="zoomInBtn" type="button" aria-label="Zoom in"><i class="fas fa-plus" aria-hidden="true"></i></button>
          <button class="ctrlIconBtn" id="zoomOutBtn" type="button" aria-label="Zoom out"><i class="fas fa-minus" aria-hidden="true"></i></button>
          <button class="ctrlIconBtn" id="resetBtn" type="button" aria-label="Recenter and fit view"><i class="fas fa-crosshairs" aria-hidden="true"></i></button>
        </div>

        <button class="recenter" id="recenterBtn" type="button" aria-label="Recenter view"><i class="fas fa-crosshairs" aria-hidden="true"></i></button>

        <div class="dock" role="group" aria-label="View mode and zoom readout">
          <div class="segmented" role="group" aria-label="View mode">
            <button id="modeFit" type="button" class="active" aria-pressed="true">Fit</button>
            <button id="modeFill" type="button" aria-pressed="false">Fill</button>
            <button id="mode100" type="button" aria-pressed="false">100%</button>
          </div>
          <div class="zoomReadout" id="zoomReadout" aria-label="Zoom percentage and active mode">
            <i class="fas fa-magnifying-glass" aria-hidden="true"></i>
            <span id="zoomPct">100%</span>
            <span class="modeTag" id="modeTag">Fit</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Deck modal with focus trap -->
  <div class="modal" id="deckModal" role="dialog" aria-modal="true" aria-label="Choose a deck">
    <span class="focus-trap-start" tabindex="0"></span>
    <div class="modalCard">
      <div class="modalHead">
        <div class="modalTitle">Choose a deck</div>
        <button class="btn" id="closeDecksBtn" type="button" aria-label="Close deck chooser"><i class="fas fa-xmark" aria-hidden="true"></i> Close</button>
      </div>
      <div class="modalBody">
        <div style="display:flex; gap:.6rem; align-items:center; justify-content:space-between; flex-wrap:wrap; margin-bottom:.75rem;">
          <div style="opacity:.9; font-weight:600; font-size:.82rem;">Tip: ←/→ change decks. +/− zoom. 0 reset.</div>
          <div style="display:flex; gap:.5rem; flex-wrap:wrap;">
            <button class="btn" id="prevDeckBtn" type="button" aria-label="Previous deck"><i class="fas fa-chevron-left" aria-hidden="true"></i> Prev</button>
            <button class="btn" id="nextDeckBtn" type="button" aria-label="Next deck">Next <i class="fas fa-chevron-right" aria-hidden="true"></i></button>
          </div>
        </div>
        <div class="deckGrid" id="deckGrid" aria-label="Deck list"></div>
      </div>
    </div>
    <span class="focus-trap-end" tabindex="0"></span>
  </div>

  <noscript>
    <div style="position:fixed;inset:auto 0 0 0;padding:1rem;text-align:center;background:#ffd740;color:#0d2236;font-weight:900;z-index:9999;">
      This page needs JavaScript enabled to load deck SVGs.
    </div>
  </noscript>

<script>
(() => {
  'use strict';

  // ----- Logging (milestones as info, not warn) -----
  const DEBUG = true;
  const Log = {
    milestone: (msg, data) => { if (DEBUG) console.info('[DeckNav]', msg, data || ''); },
    warn:      (msg, data) => { if (DEBUG) console.warn('[DeckNav]', msg, data || ''); },
    error:     (msg, data) => { console.error('[DeckNav]', msg, data || ''); }
  };

  // ----- Deck manifest -----
  const DECK_MANIFEST = [2,3,4,5,6,7,8,9,10,11,12,14].map(n => ({
    num: n,
    id: String(n).padStart(2,'0'),
    path: `decks/deck-${String(n).padStart(2,'0')}-final.min.svg`
  }));

  // ----- DOM elements -----
  const frame = document.getElementById('frame');
  const stage = document.getElementById('stage');
  const panZoom = document.getElementById('panZoom');
  const svgContainer = document.getElementById('svgContainer');
  const openDecksBtn = document.getElementById('openDecksBtn');
  const openDecksBtn2 = document.getElementById('openDecksBtn2');
  const closeDecksBtn = document.getElementById('closeDecksBtn');
  const deckModal = document.getElementById('deckModal');
  const deckGrid = document.getElementById('deckGrid');
  const prevDeckBtn = document.getElementById('prevDeckBtn');
  const nextDeckBtn = document.getElementById('nextDeckBtn');
  const deckPillText = document.getElementById('deckPillText');
  const loadingOverlay = document.getElementById('loadingOverlay');
  const errorOverlay = document.getElementById('errorOverlay');
  const loadingPath = document.getElementById('loadingPath');
  const errorMsg = document.getElementById('errorMsg');
  const errorPath = document.getElementById('errorPath');
  const retryBtn = document.getElementById('retryBtn');
  const dismissErrorBtn = document.getElementById('dismissErrorBtn');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const resetBtn = document.getElementById('resetBtn');
  const recenterBtn = document.getElementById('recenterBtn');
  const modeFitBtn = document.getElementById('modeFit');
  const modeFillBtn = document.getElementById('modeFill');
  const mode100Btn = document.getElementById('mode100');
  const zoomPctEl = document.getElementById('zoomPct');
  const modeTagEl = document.getElementById('modeTag');
  const intro = document.getElementById('intro');

  // ----- State (single source of truth) -----
  const STORAGE_KEY = 'rccl.decknav.state.v2';
  const INTRO_KEY = 'rccl.decknav.introShown.v1';
  const SVG_CACHE = new Map(); // cache fetched SVG text

  const State = {
    deckIndex: 0,
    viewMode: 'fit',          // 'fit' | 'fill' | '100'
    scale: 1,
    tx: 0,
    ty: 0,
    minScale: 0.35,
    maxScale: 5.0,
    baseW: 1000,
    baseH: 1000,
    svgLoaded: false,         // true when SVG is in DOM and measured
    loadTimer: null,
    animationFrame: null,
    visibilityHidden: false,
  };

  // ----- Persistence helpers -----
  function persistState() {
    try {
      const slim = {
        deckIndex: State.deckIndex,
        viewMode: State.viewMode,
        scale: State.scale,
        tx: State.tx,
        ty: State.ty
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(slim));
    } catch (e) { Log.warn('persistState failed', e); }
  }

  function restoreState() {
    try {
      const saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null');
      if (!saved) return;
      if (Number.isFinite(saved.deckIndex)) State.deckIndex = clampInt(saved.deckIndex, 0, DECK_MANIFEST.length-1);
      if (typeof saved.viewMode === 'string') State.viewMode = ['fit','fill','100'].includes(saved.viewMode) ? saved.viewMode : 'fit';
      if (Number.isFinite(saved.scale)) State.scale = clamp(saved.scale, State.minScale, State.maxScale);
      if (Number.isFinite(saved.tx)) State.tx = saved.tx;
      if (Number.isFinite(saved.ty)) State.ty = saved.ty;
    } catch (e) { Log.warn('restoreState failed', e); }
  }

  // ----- Utilities -----
  const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
  const clampInt = (v, min, max) => Math.min(Math.max(Math.trunc(v), min), max);
  const prefersReducedMotion = () => window.matchMedia?.('(prefers-reduced-motion: reduce)').matches;

  function setOverlay(which, show, msg, path) {
    if (which === 'loading') {
      loadingOverlay.classList.toggle('show', !!show);
      if (path) loadingPath.textContent = path;
    } else if (which === 'error') {
      errorOverlay.classList.toggle('show', !!show);
      if (msg) errorMsg.textContent = msg;
      if (path) errorPath.textContent = path;
    }
  }

  function setModeButtons(mode) {
    [modeFitBtn, modeFillBtn, mode100Btn].forEach(b => {
      if (!b) return;
      b.classList.remove('active');
      b.setAttribute('aria-pressed', 'false');
    });
    const map = { fit: modeFitBtn, fill: modeFillBtn, '100': mode100Btn };
    const btn = map[mode];
    if (btn) { btn.classList.add('active'); btn.setAttribute('aria-pressed', 'true'); }
    modeTagEl.textContent = mode === '100' ? '100%' : (mode === 'fill' ? 'Fill' : 'Fit');
  }

  function updateZoomReadout() {
    zoomPctEl.textContent = `${Math.round(State.scale * 100)}%`;
  }

  function applyTransform() {
    panZoom.style.transform = `translate(${State.tx}px, ${State.ty}px) scale(${State.scale})`;
    updateZoomReadout();
    const moved = Math.abs(State.tx) > 30 || Math.abs(State.ty) > 30;
    recenterBtn.classList.toggle('show', moved);
  }

  // ----- Geometry / fit calculations -----
  function computeFitScale(mode) {
    const fr = frame.getBoundingClientRect();
    const vw = Math.max(1, fr.width);
    const vh = Math.max(1, fr.height);
    const sW = vw / State.baseW;
    const sH = vh / State.baseH;
    if (mode === 'fill') return sW * 1.08;
    if (mode === 'fit') return Math.min(sW, sH) * 1.03;
    return 1;
  }

  function resetToMode(mode) {
    State.viewMode = mode;
    setModeButtons(mode);
    if (mode === '100') {
      State.scale = 1;
      State.tx = 0; State.ty = 0;
    } else {
      State.scale = clamp(computeFitScale(mode), State.minScale, State.maxScale);
      State.tx = 0; State.ty = 0;
    }
    applyTransform();
    persistState();
  }

  function setScaleAroundPoint(newScale, clientX, clientY) {
    const fr = frame.getBoundingClientRect();
    const pX = clientX - fr.left;
    const pY = clientY - fr.top;
    const oldScale = State.scale;
    const clamped = clamp(newScale, State.minScale, State.maxScale);
    const ratio = clamped / oldScale;
    State.tx = pX - (pX - State.tx) * ratio;
    State.ty = pY - (pY - State.ty) * ratio;
    State.scale = clamped;
    applyTransform();
    persistState();
  }

  // ----- Inline SVG loading (replaces <object>) -----
  async function loadActiveDeck({ reason = 'unknown' } = {}) {
    const deck = DECK_MANIFEST[State.deckIndex] || DECK_MANIFEST[0];
    if (!deck) return;

    Log.milestone('Load deck start', { reason, deck: deck.num, path: deck.path });

    // Clear any pending load timer
    if (State.loadTimer) clearTimeout(State.loadTimer);
    State.svgLoaded = false;

    setOverlay('error', false);
    setOverlay('loading', true, null, deck.path);

    // If cached, use it
    let svgText = SVG_CACHE.get(deck.path);
    if (!svgText) {
      try {
        const res = await fetch(deck.path, { cache: 'force-cache' }); // allow caching
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        svgText = await res.text();
        SVG_CACHE.set(deck.path, svgText);
      } catch (err) {
        Log.warn('Fetch failed', { path: deck.path, error: err.message });
        setOverlay('loading', false);
        setOverlay('error', true, `Failed to load deck ${deck.num}.`, deck.path);
        renderDeckGrid();
        return;
      }
    }

    // Parse and inject SVG
    try {
      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
      const svgElement = svgDoc.documentElement;

      // Ensure viewBox for scaling
      if (!svgElement.hasAttribute('viewBox') && svgElement.hasAttribute('width') && svgElement.hasAttribute('height')) {
        const w = parseFloat(svgElement.getAttribute('width'));
        const h = parseFloat(svgElement.getAttribute('height'));
        if (!isNaN(w) && !isNaN(h)) {
          svgElement.setAttribute('viewBox', `0 0 ${w} ${h}`);
        }
      }

      // Clear previous SVG
      while (svgContainer.firstChild) svgContainer.removeChild(svgContainer.firstChild);
      svgContainer.appendChild(svgElement);

      // Give it an id for easy querying
      svgElement.id = 'inlineSvg';

      // Wait for layout to measure intrinsic size
      requestAnimationFrame(() => {
        const rect = svgElement.getBoundingClientRect();
        State.baseW = rect.width > 10 ? rect.width : frame.clientWidth * 0.9;
        State.baseH = rect.height > 10 ? rect.height : frame.clientHeight * 0.9;
        State.svgLoaded = true;

        Log.milestone('Measured inline SVG', { baseW: State.baseW, baseH: State.baseH });

        resetToMode(State.viewMode);
        setDeckPill();
        setOverlay('loading', false);
        renderDeckGrid();

        // If URL hash, center on that venue
        tryHashVenue();
      });

    } catch (err) {
      Log.error('SVG injection failed', err);
      setOverlay('loading', false);
      setOverlay('error', true, 'SVG parsing failed.', deck.path);
      renderDeckGrid();
    }
  }

  // ----- Deck selection UI -----
  function setDeckPill() {
    const d = DECK_MANIFEST[State.deckIndex] || DECK_MANIFEST[0];
    deckPillText.textContent = `Deck ${d.num}`;
  }

  function renderDeckGrid() {
    if (!deckGrid) return;
    deckGrid.innerHTML = '';
    const activeDeck = DECK_MANIFEST[State.deckIndex];
    const currentErrorPath = errorOverlay.classList.contains('show') ? errorPath.textContent : null;

    DECK_MANIFEST.forEach((d, i) => {
      const tile = document.createElement('button');
      tile.type = 'button';
      tile.className = `deckTile ${i === State.deckIndex ? 'active' : ''}`;
      tile.setAttribute('aria-label', `Select deck ${d.num}`);
      tile.dataset.index = i;

      const status = document.createElement('div');
      status.className = 'deckStatus';
      const icon = document.createElement('i');
      icon.className = 'fas fa-map';
      const statusText = document.createElement('span');
      statusText.textContent = 'Ready';

      if (currentErrorPath === d.path) {
        status.classList.add('missing');
        icon.className = 'fas fa-triangle-exclamation';
        statusText.textContent = 'Failed';
      }

      status.appendChild(icon);
      status.appendChild(statusText);

      tile.innerHTML = `<div class="deckNum">Deck ${d.num}</div><div class="deckPath">${d.path}</div>`;
      tile.appendChild(status);

      tile.addEventListener('click', async () => {
        State.deckIndex = i;
        persistState();
        closeDeckModal();
        await loadActiveDeck({ reason: 'tileClick' });
      });

      deckGrid.appendChild(tile);
    });
  }

  function stepDeck(delta) {
    const next = clampInt(State.deckIndex + delta, 0, DECK_MANIFEST.length - 1);
    if (next === State.deckIndex) return;
    State.deckIndex = next;
    persistState();
    loadActiveDeck({ reason: delta > 0 ? 'nextDeck' : 'prevDeck' });
  }

  // ----- Modal focus trap -----
  let previousFocus = null;
  function openDeckModal() {
    previousFocus = document.activeElement;
    deckModal.classList.add('show');
    renderDeckGrid();

    // Focus first interactive element inside modal
    const focusable = deckModal.querySelector('button, [tabindex="0"]:not(.focus-trap-start):not(.focus-trap-end)');
    if (focusable) focusable.focus();

    // Trap focus
    const trapStart = deckModal.querySelector('.focus-trap-start');
    const trapEnd = deckModal.querySelector('.focus-trap-end');
    trapStart.addEventListener('focus', () => {
      const lastFocusable = deckModal.querySelectorAll('button, [tabindex="0"]:not(.focus-trap-start):not(.focus-trap-end)');
      if (lastFocusable.length) lastFocusable[lastFocusable.length-1].focus();
    });
    trapEnd.addEventListener('focus', () => {
      const firstFocusable = deckModal.querySelector('button, [tabindex="0"]:not(.focus-trap-start):not(.focus-trap-end)');
      if (firstFocusable) firstFocusable.focus();
    });
  }

  function closeDeckModal() {
    deckModal.classList.remove('show');
    if (previousFocus) previousFocus.focus();
  }

  // ----- Venue centering (inline SVG) -----
  function tryHashVenue() {
    const hash = (location.hash || '').trim();
    if (!hash || hash.length < 2) return;
    const id = decodeURIComponent(hash.slice(1));
    centerOnVenueById(id, { animate: true });
  }

  function centerOnVenueById(id, { animate = true } = {}) {
    const svg = document.getElementById('inlineSvg');
    if (!svg) return false;
    const target = svg.getElementById(id) || svg.querySelector(`#${CSS.escape(id)}`);
    if (!target) {
      Log.warn('Venue not found', { id });
      return false;
    }
    return centerOnSvgElement(target, { animate });
  }

  function centerOnSvgElement(el, { animate = true } = {}) {
    const fr = frame.getBoundingClientRect();
    const prevTransition = panZoom.style.transition;
    if (!animate || prefersReducedMotion()) panZoom.style.transition = 'none';

    const targetRect = el.getBoundingClientRect();
    const targetCX = targetRect.left + targetRect.width/2;
    const targetCY = targetRect.top + targetRect.height/2;
    const frameCX = fr.left + fr.width/2;
    const frameCY = fr.top + fr.height/2;

    State.tx += frameCX - targetCX;
    State.ty += frameCY - targetCY;
    applyTransform();
    persistState();

    if (!animate || prefersReducedMotion()) {
      requestAnimationFrame(() => { panZoom.style.transition = prevTransition; });
    }
    return true;
  }

  // ----- Pointer gestures (unchanged but now work on inline SVG) -----
  const pointers = new Map();
  let gesture = { isPanning: false, startTx:0, startTy:0, startX:0, startY:0, startDist:0, startScale:1, startMidX:0, startMidY:0 };

  function pointerMidpoint() {
    const vals = Array.from(pointers.values());
    return { x: (vals[0].x + vals[1].x)/2, y: (vals[0].y + vals[1].y)/2 };
  }
  function pointerDistance() {
    const vals = Array.from(pointers.values());
    return Math.hypot(vals[0].x - vals[1].x, vals[0].y - vals[1].y);
  }

  function onPointerDown(e) {
    frame.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    if (pointers.size === 1) {
      gesture.isPanning = true;
      gesture.startTx = State.tx; gesture.startTy = State.ty;
      gesture.startX = e.clientX; gesture.startY = e.clientY;
    } else if (pointers.size === 2) {
      gesture.isPanning = false;
      gesture.startScale = State.scale;
      gesture.startDist = pointerDistance();
      const mid = pointerMidpoint();
      gesture.startMidX = mid.x; gesture.startMidY = mid.y;
    }
  }

  function onPointerMove(e) {
    if (!pointers.has(e.pointerId)) return;
    pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    if (pointers.size === 1 && gesture.isPanning) {
      State.tx = gesture.startTx + (e.clientX - gesture.startX);
      State.ty = gesture.startTy + (e.clientY - gesture.startY);
      applyTransform();
    } else if (pointers.size === 2) {
      const dist = pointerDistance();
      if (dist <= 0) return;
      const scaleFactor = dist / gesture.startDist;
      const targetScale = clamp(gesture.startScale * scaleFactor, State.minScale, State.maxScale);
      const mid = pointerMidpoint();
      setScaleAroundPoint(targetScale, mid.x, mid.y);
      if (State.viewMode === '100') { State.viewMode = 'fit'; setModeButtons('fit'); }
    }
  }

  function onPointerUp(e) {
    pointers.delete(e.pointerId);
    if (pointers.size === 1) {
      const rem = Array.from(pointers.values())[0];
      gesture.isPanning = true;
      gesture.startTx = State.tx; gesture.startTy = State.ty;
      gesture.startX = rem.x; gesture.startY = rem.y;
    } else {
      gesture.isPanning = false;
    }
    persistState();
  }

  function onPointerCancel(e) {
    pointers.delete(e.pointerId);
    gesture.isPanning = false;
    persistState();
  }

  function onWheel(e) {
    e.preventDefault();
    const delta = e.deltaY;
    const zoom = delta > 0 ? 0.92 : 1.08;
    const next = clamp(State.scale * zoom, State.minScale, State.maxScale);
    setScaleAroundPoint(next, e.clientX, e.clientY);
    if (State.viewMode === '100') { State.viewMode = 'fit'; setModeButtons('fit'); }
  }

  // ----- Event wiring -----
  function wireControls() {
    openDecksBtn.addEventListener('click', openDeckModal);
    openDecksBtn2.addEventListener('click', openDeckModal);
    closeDecksBtn.addEventListener('click', closeDeckModal);
    deckModal.addEventListener('click', (e) => { if (e.target === deckModal) closeDeckModal(); });

    prevDeckBtn.addEventListener('click', () => stepDeck(-1));
    nextDeckBtn.addEventListener('click', () => stepDeck(1));

    retryBtn.addEventListener('click', () => loadActiveDeck({ reason: 'retry' }));
    dismissErrorBtn.addEventListener('click', () => setOverlay('error', false));

    zoomInBtn.addEventListener('click', () => {
      const fr = frame.getBoundingClientRect();
      setScaleAroundPoint(State.scale * 1.15, fr.left + fr.width/2, fr.top + fr.height/2);
      State.viewMode = 'fit'; setModeButtons('fit'); persistState();
    });
    zoomOutBtn.addEventListener('click', () => {
      const fr = frame.getBoundingClientRect();
      setScaleAroundPoint(State.scale / 1.15, fr.left + fr.width/2, fr.top + fr.height/2);
      State.viewMode = 'fit'; setModeButtons('fit'); persistState();
    });
    resetBtn.addEventListener('click', () => resetToMode(State.viewMode === '100' ? 'fit' : State.viewMode));
    recenterBtn.addEventListener('click', () => resetToMode(State.viewMode === '100' ? 'fit' : State.viewMode));

    modeFitBtn.addEventListener('click', () => resetToMode('fit'));
    modeFillBtn.addEventListener('click', () => resetToMode('fill'));
    mode100Btn.addEventListener('click', () => resetToMode('100'));

    frame.addEventListener('pointerdown', onPointerDown);
    frame.addEventListener('pointermove', onPointerMove);
    frame.addEventListener('pointerup', onPointerUp);
    frame.addEventListener('pointercancel', onPointerCancel);
    frame.addEventListener('wheel', onWheel, { passive: false });

    // Keyboard shortcuts
    frame.addEventListener('keydown', (e) => {
      const k = e.key;
      if (k === 'ArrowLeft') { e.preventDefault(); stepDeck(-1); }
      else if (k === 'ArrowRight') { e.preventDefault(); stepDeck(1); }
      else if (k === '+' || k === '=') { e.preventDefault(); zoomInBtn.click(); }
      else if (k === '-' || k === '_') { e.preventDefault(); zoomOutBtn.click(); }
      else if (k === '0') { e.preventDefault(); resetBtn.click(); }
      else if (k === 'Escape' && deckModal.classList.contains('show')) { e.preventDefault(); closeDeckModal(); }
      else if (k === 'd' || k === 'D') { e.preventDefault(); openDeckModal(); }
    });

    window.addEventListener('hashchange', tryHashVenue);
  }

  // ----- Ocean background (performance: pause when hidden) -----
  const ocean = document.getElementById('ocean');
  const ctx = ocean?.getContext('2d');
  let oceanT = 0;

  function resizeOcean() {
    if (!ocean || !ctx) return;
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    ocean.width = Math.floor(innerWidth * dpr);
    ocean.height = Math.floor(innerHeight * dpr);
    ocean.style.width = innerWidth + 'px';
    ocean.style.height = innerHeight + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  function drawOcean() {
    if (!ocean || !ctx || State.visibilityHidden) {
      State.animationFrame = requestAnimationFrame(drawOcean);
      return;
    }
    const w = innerWidth, h = innerHeight;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = '#071a2c';
    ctx.fillRect(0,0,w,h);

    const grad = ctx.createLinearGradient(0,0,0,h);
    grad.addColorStop(0,'rgba(10,46,74,.10)');
    grad.addColorStop(1,'rgba(0,0,0,.28)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,w,h);

    const speed = prefersReducedMotion() ? 0.004 : 0.012;

    for (let i=0; i<3; i++) {
      const amp = 22 + i*12;
      const len = 0.010 - i*0.0018;
      const base = h*(0.48 + i*0.07);
      ctx.beginPath();
      ctx.moveTo(0, base);
      for (let x=0; x<=w; x+=8) {
        const y = base + Math.sin(x*len + oceanT*(0.9+i*0.2)) * amp;
        ctx.lineTo(x,y);
      }
      ctx.lineTo(w,h);
      ctx.lineTo(0,h);
      ctx.closePath();
      ctx.fillStyle = `rgba(0,180,230,${0.12 - i*0.03})`;
      ctx.fill();
    }

    oceanT += speed;
    State.animationFrame = requestAnimationFrame(drawOcean);
  }

  // Visibility API
  document.addEventListener('visibilitychange', () => {
    State.visibilityHidden = document.hidden;
  });

  // Ship parallax (throttled)
  const shipSil = document.querySelector('.ship-sil');
  let lastShipMove = 0;
  window.addEventListener('pointermove', (e) => {
    if (!shipSil) return;
    const now = performance.now();
    if (now - lastShipMove < 16) return; // ~60fps
    lastShipMove = now;
    const x = (e.clientX / Math.max(1, innerWidth)) - 0.5;
    shipSil.style.transform = `translateX(-50%) translateY(${x * 8}px)`;
  }, { passive: true });

  // Intro once per session
  function showIntroOnce() {
    if (prefersReducedMotion()) return;
    try {
      if (sessionStorage.getItem(INTRO_KEY)) return;
      sessionStorage.setItem(INTRO_KEY, '1');
      intro.classList.add('show');
      setTimeout(() => intro.classList.remove('show'), 1100);
    } catch {}
  }

  // ----- Init -----
  async function init() {
    Log.milestone('Init start');
    restoreState();

    // URL deck param
    const url = new URL(location.href);
    const deckParam = url.searchParams.get('deck')?.trim();
    if (deckParam) {
      const idx = DECK_MANIFEST.findIndex(d => d.id === deckParam || String(d.num) === deckParam);
      if (idx >= 0) State.deckIndex = idx;
    }

    setModeButtons(State.viewMode);
    setDeckPill();
    updateZoomReadout();
    wireControls();

    resizeOcean();
    State.animationFrame = requestAnimationFrame(drawOcean);
    window.addEventListener('resize', () => {
      resizeOcean();
      if (State.viewMode !== '100' && State.svgLoaded) resetToMode(State.viewMode);
    });

    showIntroOnce();
    renderDeckGrid();
    await loadActiveDeck({ reason: 'init' });

    Log.milestone('Init complete');
  }

  init();
})();
</script>
</body>
</html>