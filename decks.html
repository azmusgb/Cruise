<!DOCTYPE html>
<html lang="en"><head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Deck Navigator · Adventure of the Seas</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&amp;family=Plus+Jakarta+Sans:wght@700;800;900&amp;display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <link rel="stylesheet" href="css/tokens.css">
  <link rel="stylesheet" href="css/base.css">
  <link rel="stylesheet" href="css/utilities.css">
  <link rel="stylesheet" href="css/layout.css">
  <link rel="stylesheet" href="css/components.css">
  <link rel="stylesheet" href="css/features.css">
  <link rel="stylesheet" href="css/mobile-first.css">
</head>

<body class="app-theme-rcc page-decks">
  <canvas id="ocean" width="750" height="1218" style="width: 375px; height: 609px;"></canvas>
  <div class="vignette" aria-hidden="true"></div>

  <header>
    <div class="hdr">
      <i class="fas fa-crown" style="color:var(--gold);font-size:.9rem"></i>
      <div>
        <div class="brand-title">Adventure of the Seas</div>
        <div class="brand-sub">Rahe Family · Deck Navigator</div>
      </div>
      <div class="spacer"></div>
      <span class="hdr-pill"><i class="fas fa-calendar-alt"></i> Feb 14–20</span>
      <button class="hdr-btn" id="menuBtn" aria-label="Menu"><i class="fas fa-bars"></i></button>
    </div>
  </header>

  <div class="hero">
    <h1>Deck Navigator</h1>
    <p>Find anything on the ship in seconds.</p>
  </div>

  <div class="search-wrap">
    <div class="search-box">
      <i class="fas fa-search"></i>
      <input id="deckSearch" type="search" placeholder="Search decks or venues…" autocomplete="off" aria-label="Search decks">
    </div>
  </div>

  <div class="filters" id="filters">
    <button class="f-btn active" data-f="all" aria-pressed="true">All</button>
    <button class="f-btn" data-f="entertainment" aria-pressed="false">Entertainment</button>
    <button class="f-btn" data-f="wellness" aria-pressed="false">Wellness</button>
    <button class="f-btn" data-f="essential" aria-pressed="false">Essential</button>
  </div>

  <div class="content" id="content"><div class="overview-card" data-n="0">
        <div class="overview-icon"><i class="fas fa-layer-group"></i></div>
        <div class="overview-text">
          <strong>All Decks — Ship Overview</strong>
          <span>Full blueprint · Quick orientation</span>
        </div>
        <i class="fas fa-chevron-right overview-arrow"></i>
      </div><div class="sec-head">
        <span class="sec-icon ent"><i class="fas fa-masks-theater"></i></span>
        <div><div class="sec-title">Entertainment</div></div>
        <span class="sec-count">5</span>
      </div><div class="deck-grid"><div class="deck-card" data-n="5" role="button" tabindex="0" aria-label="Open Royal Promenade">
            <div class="card-top">
              <span class="card-num">5</span>
              <i class="fas fa-chevron-right card-arrow"></i>
            </div>
            <div class="card-name">Royal Promenade</div>
            <div class="card-tags"><span class="card-tag">Shops</span><span class="card-tag">Dining</span><span class="card-tag">Parades</span></div>
          </div><div class="deck-card" data-n="4" role="button" tabindex="0" aria-label="Open Dining &amp; Entertainment">
            <div class="card-top">
              <span class="card-num">4</span>
              <i class="fas fa-chevron-right card-arrow"></i>
            </div>
            <div class="card-name">Dining &amp; Entertainment</div>
            <div class="card-tags"><span class="card-tag">Main Dining</span><span class="card-tag">Theater</span><span class="card-tag">Casino</span></div>
          </div><div class="deck-card" data-n="3" role="button" tabindex="0" aria-label="Open Lobby &amp; Guest Services">
            <div class="card-top">
              <span class="card-num">3</span>
              <i class="fas fa-chevron-right card-arrow"></i>
            </div>
            <div class="card-name">Lobby &amp; Guest Services</div>
            <div class="card-tags"><span class="card-tag">Grand Lobby</span><span class="card-tag">Shore Ex</span><span class="card-tag">Retail</span></div>
          </div><div class="deck-card" data-n="13" role="button" tabindex="0" aria-label="Open Adventure Zone">
            <div class="card-top">
              <span class="card-num">13</span>
              <i class="fas fa-chevron-right card-arrow"></i>
            </div>
            <div class="card-name">Adventure Zone</div>
            <div class="card-tags"><span class="card-tag">Rock Wall</span><span class="card-tag">Activities</span></div>
          </div><div class="deck-card" data-n="14" role="button" tabindex="0" aria-label="Open Sky Deck">
            <div class="card-top">
              <span class="card-num">14</span>
              <i class="fas fa-chevron-right card-arrow"></i>
            </div>
            <div class="card-name">Sky Deck</div>
            <div class="card-tags"><span class="card-tag">Viking Crown</span><span class="card-tag">Views</span><span class="card-tag">Lounges</span></div>
          </div></div><div class="sec-head">
        <span class="sec-icon wel"><i class="fas fa-water-ladder"></i></span>
        <div><div class="sec-title">Wellness &amp; Activities</div></div>
        <span class="sec-count">3</span>
      </div><div class="deck-grid"><div class="deck-card" data-n="11" role="button" tabindex="0" aria-label="Open Fitness &amp; Spa">
            <div class="card-top">
              <span class="card-num">11</span>
              <i class="fas fa-chevron-right card-arrow"></i>
            </div>
            <div class="card-name">Fitness &amp; Spa</div>
            <div class="card-tags"><span class="card-tag">Vitality Spa</span><span class="card-tag">Gym</span><span class="card-tag">Wellness</span></div>
          </div><div class="deck-card" data-n="12" role="button" tabindex="0" aria-label="Open Pool Deck">
            <div class="card-top">
              <span class="card-num">12</span>
              <i class="fas fa-chevron-right card-arrow"></i>
            </div>
            <div class="card-name">Pool Deck</div>
            <div class="card-tags"><span class="card-tag">Main Pool</span><span class="card-tag">Solarium</span><span class="card-tag">Windjammer</span></div>
          </div><div class="deck-card" data-n="15" role="button" tabindex="0" aria-label="Open Sports &amp; Observation">
            <div class="card-top">
              <span class="card-num">15</span>
              <i class="fas fa-chevron-right card-arrow"></i>
            </div>
            <div class="card-name">Sports &amp; Observation</div>
            <div class="card-tags"><span class="card-tag">FlowRider</span><span class="card-tag">Jog Track</span><span class="card-tag">Views</span></div>
          </div></div><div class="sec-head">
        <span class="sec-icon ess"><i class="fas fa-compass"></i></span>
        <div><div class="sec-title">Essential</div></div>
        <span class="sec-count">1</span>
      </div><div class="deck-grid"><div class="deck-card" data-n="2" role="button" tabindex="0" aria-label="Open Medical &amp; Crew">
            <div class="card-top">
              <span class="card-num">2</span>
              <i class="fas fa-chevron-right card-arrow"></i>
            </div>
            <div class="card-name">Medical &amp; Crew</div>
            <div class="card-tags"><span class="card-tag">Medical</span><span class="card-tag">Crew</span><span class="card-tag">Embark</span></div>
          </div></div><div class="sec-head">
        <span class="sec-icon ess"><i class="fas fa-bed"></i></span>
        <div><div class="sec-title">Stateroom Decks</div></div>
        <span class="sec-count">5</span>
      </div><div class="cabin-row"><button class="cabin-chip" data-n="6" aria-label="Open deck 6">
            <span class="chip-num">6</span>
            <span class="chip-label">Deck 6</span>
          </button><button class="cabin-chip" data-n="7" aria-label="Open deck 7">
            <span class="chip-num">7</span>
            <span class="chip-label">Deck 7</span>
          </button><button class="cabin-chip" data-n="8" aria-label="Open deck 8">
            <span class="chip-num">8</span>
            <span class="chip-label">Deck 8</span>
          </button><button class="cabin-chip" data-n="9" aria-label="Open deck 9">
            <span class="chip-num">9</span>
            <span class="chip-label">Deck 9</span>
          </button><button class="cabin-chip" data-n="10" aria-label="Open deck 10">
            <span class="chip-num">10</span>
            <span class="chip-label">Deck 10</span>
          </button></div></div>
  <div class="empty" id="emptyState" style="display: none;"><i class="fas fa-search"></i>No matching decks</div>

  <!-- MODAL -->
  <div class="modal" id="modal" role="dialog" aria-modal="true" aria-label="Deck details">
    <div class="modal-backdrop" id="modalBackdrop"></div>

    <div class="modal-sheet" id="modalSheet" style="box-shadow: rgba(0, 0, 0, 0.5) 0px -20px 80px, rgba(0, 200, 150, 0.25) 0px -20px 80px;">
      <div class="drag-handle"><span></span></div>

      <div class="modal-bar">
        <button class="modal-nav" id="prevBtn" aria-label="Previous deck"><i class="fas fa-chevron-left"></i></button>
        <button class="modal-nav" id="nextBtn" aria-label="Next deck"><i class="fas fa-chevron-right"></i></button>
        <div class="modal-titles">
          <div class="modal-title" id="modalTitle">Deck 11 — Fitness &amp; Spa</div>
          <div class="modal-sub" id="modalSub">Vitality Spa · Gym · Wellness</div>
          <div class="modal-mode" id="modalMode" aria-live="polite"></div>
        </div>
        <button class="modal-close-btn" id="modalClose" aria-label="Close"><i class="fas fa-times"></i></button>
      </div>

      <div class="modal-body">
        <div class="plan-viewer" id="planViewer" aria-label="Deck plan viewer">
          <div class="shimmer hidden" id="shimmer"></div>
          <img class="plan-img loaded" id="planImg" src="decks/deck-11-final.min.svg" alt="Deck 11" draggable="false" style="transform: translate(-373px, -1515.43381px) scale(2);">
          <div class="hotspots-layer" id="hotspotsLayer" style="transform: translate(-373px, -1515.43381px) scale(2);"><button class="hotspot-btn" data-spot-idx="0" style="left:48%; top:44%;" aria-label="Vitality Spa: Thermal suite &amp; massages">1</button><button class="hotspot-btn" data-spot-idx="1" style="left:30%; top:55%;" aria-label="Fitness Center: Panoramic treadmills">2</button></div>
        </div>

        <!-- Premium Quick Jump Rail -->
        <div class="deck-rail" aria-hidden="false">
          <div class="rail-wrap" id="railWrap" aria-label="Quick deck jump">
            <div class="rail-mini">
              <button id="railUp" aria-label="Deck up"><i class="fas fa-chevron-up"></i></button>
            </div>
            <div class="rail-track" id="railTrack">
              <div class="rail-thumb" id="railThumb" aria-label="Deck slider" style="top: 93.602163px;">11</div>
            <div class="rail-tick" style="top: 18px;"></div><div class="rail-tick" style="top: 26.40024px;"></div><div class="rail-tick" style="top: 34.800481px;"></div><div class="rail-tick" style="top: 43.200721px;"></div><div class="rail-tick" style="top: 51.600962px;"></div><div class="rail-tick" style="top: 60.001202px;"></div><div class="rail-tick" style="top: 68.401442px;"></div><div class="rail-tick" style="top: 76.801683px;"></div><div class="rail-tick" style="top: 85.201923px;"></div><div class="rail-tick active" style="top: 93.602163px;"></div><div class="rail-tick" style="top: 102.002404px;"></div><div class="rail-tick" style="top: 110.402644px;"></div><div class="rail-tick" style="top: 118.802885px;"></div><div class="rail-tick" style="top: 127.203125px;"></div></div>
            <div class="rail-mini">
              <button id="railDown" aria-label="Deck down"><i class="fas fa-chevron-down"></i></button>
            </div>
            <div class="rail-label" id="railActiveLabel" aria-label="Current deck">D11</div>
          </div>
        </div>

        <div class="zoom-row">
          <button class="zoom-btn" id="zoomOut" aria-label="Zoom out"><i class="fas fa-minus"></i></button>
          <input type="range" class="zoom-track" id="zoomRange" min="50" max="400" value="100" aria-label="Zoom range">
          <button class="zoom-btn" id="zoomIn" aria-label="Zoom in"><i class="fas fa-plus"></i></button>
          <span class="zoom-pct" id="zoomPct">200%</span>

          <!-- Auto-fit button -->
          <button class="zoom-btn" id="zoomFit" aria-label="Auto fit"><i class="fas fa-arrows-to-circle"></i></button>
        </div>

        <div class="chips-row" id="chipsRow"><button class="chip" aria-label="Filter Vitality Spa">Vitality Spa</button><button class="chip" aria-label="Filter Fitness">Fitness</button></div>
        <div class="legend" id="legend">
      <button class="legend-item" data-spot-idx="0" aria-label="Highlight Vitality Spa">
        <span class="legend-n">1</span>
        <div class="legend-t"><strong>Vitality Spa</strong><span>Thermal suite &amp; massages</span></div>
      </button>
      <button class="legend-item" data-spot-idx="1" aria-label="Highlight Fitness Center">
        <span class="legend-n">2</span>
        <div class="legend-t"><strong>Fitness Center</strong><span>Panoramic treadmills</span></div>
      </button></div>
      </div>

      <div class="modal-footer">
        <button class="foot-btn" id="btnLoc"><i class="fas fa-location-dot"></i> My Location</button>
        <button class="foot-btn" id="btnPDF" type="button" disabled aria-disabled="true"><i class="fas fa-file-pdf"></i> PDF</button>
        <button class="foot-btn primary" id="btnClose2"><i class="fas fa-times"></i> Close</button>
      </div>
    </div>
  </div>

  <!-- DRAWER -->
  <div class="drawer-backdrop" id="drawerBackdrop" aria-hidden="true">
    <aside class="drawer" role="dialog" aria-modal="true" aria-label="Navigation menu">
      <div class="drawer-head">
        <h3>Navigate</h3>
        <button class="hdr-btn" id="closeDrawerBtn" aria-label="Close menu"><i class="fas fa-times"></i></button>
      </div>
      <nav class="nav">
        <a href="index.html"><i class="fas fa-home"></i> Dashboard</a>
        <a href="itinerary.html"><i class="fas fa-route"></i> Itinerary</a>
        <a href="rooms.html"><i class="fas fa-bed"></i> Rooms</a>
        <a href="decks.html" class="active" aria-current="page"><i class="fas fa-layer-group"></i> Decks</a>
        <a href="operations.html"><i class="fas fa-list-check"></i> Checklist</a>
        <a href="contacts.html"><i class="fas fa-phone"></i> Contacts</a>
        <a href="dining.html"><i class="fas fa-utensils"></i> Dining</a>
        <a href="tips.html"><i class="fas fa-lightbulb"></i> Tips</a>
      </nav>
    </aside>
  </div>

  <!-- BACK TO TOP -->
  <button class="back-to-top" id="backToTop" aria-label="Back to top"><i class="fas fa-arrow-up"></i></button>

  <!-- TOAST -->
  <div class="toast" id="toast" role="status" aria-live="polite">
    <i class="fas fa-circle-check"></i>
    <span id="toastText">Loaded Deck 11</span>
  </div>

<script>
(() => {
  'use strict';

  /* ===========================
     DATA (update paths to match your repo)
     =========================== */
  const DECKS = [
    { n:0,  name:'All Decks',  sub:'Ship Overview', tags:['Full layout','Orientation'], cat:'essential', svg:'decks/deck-all.min.svg', pdf:'', chips:[], spots:[] },

    { n:5,  name:'Deck 5', sub:'Royal Promenade', tags:['Shops','Dining','Parades'], cat:'entertainment', svg:'decks/deck-05-final.min.svg', pdf:'decks/deck-05.pdf',
      chips:['Cafe Promenade','Guest Services'],
      spots:[
        { t:'Cafe Promenade', n:'24h coffee & snacks', x:55, y:48, type:'dining' },
        { t:'Guest Services', n:'Crown & Anchor desk', x:48, y:60, type:'service' }
      ] },

    { n:4,  name:'Deck 4', sub:'Dining & Entertainment', tags:['Main Dining','Theater','Casino'], cat:'entertainment', svg:'decks/deck-04-final.min.svg', pdf:'',
      chips:['Main Dining','Royal Theater','Casino'],
      spots:[
        { t:'Main Dining Room', n:'Dinner 6–9:30pm', x:35, y:55, type:'dining' },
        { t:'Royal Theater', n:'Shows 7pm & 9:30pm', x:65, y:40, type:'entertainment' },
        { t:'Casino Royale', n:'Slots, tables, poker', x:50, y:70, type:'entertainment' }
      ] },

    { n:3,  name:'Deck 3', sub:'Lobby & Guest Services', tags:['Grand Lobby','Shore Ex','Retail'], cat:'entertainment', svg:'decks/deck-03-final.min.svg', pdf:'',
      chips:['Grand Lobby','Shore Excursions'],
      spots:[
        { t:'Grand Lobby', n:'Atrium & champagne bar', x:40, y:50, type:'essential' },
        { t:'Shore Excursions', n:'Booking desk', x:55, y:45, type:'service' }
      ] },

    { n:2,  name:'Deck 2', sub:'Medical & Crew', tags:['Medical','Crew','Embark'], cat:'essential', svg:'decks/deck-02-final.min.svg', pdf:'',
      chips:['Medical Center'],
      spots:[{ t:'Medical Center', n:'24h emergency care', x:50, y:50, type:'essential' }] },

    { n:11, name:'Deck 11', sub:'Fitness & Spa', tags:['Vitality Spa','Gym','Wellness'], cat:'wellness', svg:'decks/deck-11-final.min.svg', pdf:'',
      chips:['Vitality Spa','Fitness'],
      spots:[
        { t:'Vitality Spa', n:'Thermal suite & massages', x:48, y:44, type:'wellness' },
        { t:'Fitness Center', n:'Panoramic treadmills', x:30, y:55, type:'wellness' }
      ] },

    { n:12, name:'Deck 12', sub:'Pool Deck', tags:['Main Pool','Solarium','Windjammer'], cat:'wellness', svg:'decks/deck-12-final.min.svg', pdf:'',
      chips:['Main Pool','Solarium','Windjammer'],
      spots:[
        { t:'Main Pool', n:'Live music & bar', x:40, y:60, type:'activity' },
        { t:'Solarium', n:'Adults-only pool', x:70, y:30, type:'wellness' },
        { t:'Windjammer Cafe', n:'Buffet with ocean view', x:20, y:70, type:'dining' }
      ] },

    { n:13, name:'Deck 13', sub:'Adventure Zone', tags:['Rock Wall','Activities'], cat:'entertainment', svg:'decks/deck-13-final.min.svg', pdf:'',
      chips:['Rock Wall'],
      spots:[{ t:'Rock Climbing Wall', n:'Up to 40ft tall', x:60, y:70, type:'activity' }] },

    { n:14, name:'Deck 14', sub:'Sky Deck', tags:['Viking Crown','Views','Lounges'], cat:'entertainment', svg:'decks/deck-14-final.min.svg', pdf:'',
      chips:['Viking Crown'],
      spots:[{ t:'Viking Crown Lounge', n:'360° sky bar', x:50, y:30, type:'entertainment' }] },

    { n:15, name:'Deck 15', sub:'Sports & Observation', tags:['FlowRider','Jog Track','Views'], cat:'wellness', svg:'decks/deck-15-final.min.svg', pdf:'',
      chips:['FlowRider','Mini Golf'],
      spots:[
        { t:'FlowRider', n:'Surf simulator', x:30, y:40, type:'activity' },
        { t:'Mini Golf', n:'9-hole course', x:70, y:50, type:'activity' },
        { t:'Running Track', n:'Outdoor jogging loop', x:50, y:80, type:'activity' }
      ] },

    { n:6,  name:'Deck 6', sub:'Staterooms', tags:['Cabins','Midship'], cat:'cabin', svg:'decks/deck-06-final.min.svg', pdf:'', chips:[], spots:[] },
    { n:7,  name:'Deck 7', sub:'Staterooms', tags:['Cabins'], cat:'cabin', svg:'decks/deck-07-final.min.svg', pdf:'', chips:[], spots:[] },
    { n:8,  name:'Deck 8', sub:'Staterooms', tags:['Cabins'], cat:'cabin', svg:'decks/deck-08-final.min.svg', pdf:'', chips:[], spots:[] },
    { n:9,  name:'Deck 9', sub:'Staterooms', tags:['Cabins'], cat:'cabin', svg:'decks/deck-09-final.min.svg', pdf:'', chips:[], spots:[] },
    { n:10, name:'Deck 10', sub:'Staterooms', tags:['Cabins'], cat:'cabin', svg:'decks/deck-10-final.min.svg', pdf:'', chips:[], spots:[] },
  ];

  const SECTIONS = [
    { key:'entertainment', label:'Entertainment', icon:'fas fa-masks-theater', cls:'ent', decks: DECKS.filter(d => d.cat==='entertainment' && d.n!==0).map(d=>d.n) },
    { key:'wellness',      label:'Wellness & Activities', icon:'fas fa-water-ladder', cls:'wel', decks: DECKS.filter(d => d.cat==='wellness').map(d=>d.n) },
    { key:'essential',     label:'Essential', icon:'fas fa-compass', cls:'ess', decks: DECKS.filter(d => d.cat==='essential' && d.n!==0).map(d=>d.n) },
    { key:'cabin',         label:'Stateroom Decks', icon:'fas fa-bed', cls:'ess', decks: DECKS.filter(d => d.cat==='cabin').map(d=>d.n) },
  ];

  const byNum = (n) => DECKS.find(d => d.n === n) || null;
  const ordered = DECKS.filter(d => d.n !== 0).sort((a,b) => a.n - b.n);
  const reducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  /* ===========================
     STATE
     =========================== */
  let filt = 'all';
  let query = '';
  let currentDeck = null;

  // Prevent stale deck loads when user scrubs the rail quickly
  let activeDeckToken = 0;

  // Modal focus management
  let lastFocusedBeforeModal = null;

  // Debounced resize
  let resizeTimer = 0;

  // Double-tap disambiguation (avoid micro-pan before zoom)
  const TAP_MAX_MOVE_PX = 8;
  const TAP_MAX_MS = 260;
  let tapStart = null;   // {x,y,t}
  let tapMoved = false;

  // Preload cache for adjacent decks
  const preloadCache = new Map(); // path -> {img, ok}

  function isImageReady() {
    return !!(planImg && planImg.complete && planImg.naturalWidth > 0);
  }

  /* ===========================
     DOM
     =========================== */
  const $ = (id) => document.getElementById(id);

  const content = $('content');
  const emptyState = $('emptyState');

  const modal = $('modal');
  const backdrop = $('modalBackdrop');
  const modalSheet = $('modalSheet');
  const modalTitle = $('modalTitle');
  const modalSub = $('modalSub');
  const modalMode = $('modalMode');
  const deckAnnounce = $('deckAnnounce');

  const planViewer = $('planViewer');
  const planImg = $('planImg');
  const shimmer = $('shimmer');
  const hotspotsLayer = $('hotspotsLayer');

  const zoomRange = $('zoomRange');
  const zoomPct = $('zoomPct');
  const zoomFit = $('zoomFit');
  const zoomInBtn = $('zoomIn');
  const zoomOutBtn = $('zoomOut');

  const chipsRow = $('chipsRow');
  const legend = $('legend');

  const prevBtn = $('prevBtn');
  const nextBtn = $('nextBtn');

  const btnPDF = $('btnPDF');
  const btnLoc = $('btnLoc');

  const drawerBackdrop = $('drawerBackdrop');

  btnPDF.addEventListener('click', () => {
    const pdf = btnPDF.dataset.pdf;
    if (!pdf) return;
    window.open(pdf, '_blank', 'noopener');
  });
  const menuBtn = $('menuBtn');
  const closeDrawerBtn = $('closeDrawerBtn');

  const backToTop = $('backToTop');
  const toast = $('toast');
  const toastText = $('toastText');

  const railTrack = $('railTrack');
  const railThumb = $('railThumb');
  const railUp = $('railUp');
  const railDown = $('railDown');
  const railActiveLabel = $('railActiveLabel');

  /* ===========================
     UTIL
     =========================== */
  function safeFocus(el) { try { el && el.focus && el.focus(); } catch (_) {} }

  function showToast(msg) {
    toastText.textContent = msg;
    toast.classList.add('show');
    window.clearTimeout(showToast._t);
    showToast._t = window.setTimeout(() => toast.classList.remove('show'), 2000);
  }

  function showShimmer() { shimmer.classList.remove('hidden'); planImg.classList.remove('loaded'); }
  function hideShimmer() { shimmer.classList.add('hidden'); planImg.classList.add('loaded'); }

  function escapeHtml(str) {
    return String(str || '')
      .replaceAll('&','&amp;')
      .replaceAll('<','&lt;')
      .replaceAll('>','&gt;')
      .replaceAll('"','&quot;')
      .replaceAll("'","&#039;");
  }

  function clearSpotStates() {
    hotspotsLayer.querySelectorAll('.hotspot-btn').forEach(btn => btn.classList.remove('active','dim','smart-highlight'));
    legend.querySelectorAll('.legend-item').forEach(item => item.classList.remove('active'));
  
  /* ===========================
     MODAL FOCUS TRAP (A11Y)
     =========================== */
  function getFocusableInModal() {
    const selectors = [
      'a[href]',
      'button:not([disabled])',
      'input:not([disabled])',
      'select:not([disabled])',
      'textarea:not([disabled])',
      '[tabindex]:not([tabindex="-1"])'
    ].join(',');
    const nodes = Array.from(modalSheet.querySelectorAll(selectors));
    return nodes.filter(el => {
      const s = window.getComputedStyle(el);
      return s.display !== 'none' && s.visibility !== 'hidden' && el.offsetParent !== null;
    });
  }

  function handleModalTabTrap(e) {
    if (!modal.classList.contains('open')) return;
    if (e.key !== 'Tab') return;

    const focusables = getFocusableInModal();
    if (!focusables.length) return;

    const first = focusables[0];
    const last = focusables[focusables.length - 1];
    const active = document.activeElement;

    if (e.shiftKey) {
      if (active === first || !modalSheet.contains(active)) {
        e.preventDefault();
        last.focus();
      }
    } else {
      if (active === last) {
        e.preventDefault();
        first.focus();
      }
    }
  }

  document.addEventListener('keydown', handleModalTabTrap, true);

}

  /* ===========================
     RENDER LIST
     =========================== */
  function render() {
    const q = (query || '').trim().toLowerCase();

    const visible = (n) => {
      const d = byNum(n);
      if (!d) return false;

      const matchCat =
        (filt === 'all') ||
        (d.cat === filt) ||
        (filt === 'essential' && d.cat === 'cabin');

      const hay = `${d.name} ${d.sub} ${(d.tags||[]).join(' ')}`.toLowerCase();
      const matchQ = (!q) || hay.includes(q);

      return matchCat && matchQ;
    };

    let html = '';
    let anyVisible = false;

    const ov = byNum(0);
    const ovHay = `${ov.name} ${ov.sub} ${(ov.tags||[]).join(' ')}`.toLowerCase();
    const ovVis = (filt === 'all' || filt === 'essential') && (!q || ovHay.includes(q));
    if (ovVis) {
      anyVisible = true;
      html += `<div class="overview-card" data-n="0">
        <div class="overview-icon"><i class="fas fa-layer-group"></i></div>
        <div class="overview-text">
          <strong>All Decks — Ship Overview</strong>
          <span>Full blueprint · Quick orientation</span>
        </div>
        <i class="fas fa-chevron-right overview-arrow"></i>
      </div>`;
    }

    SECTIONS.forEach(sec => {
      const visDecks = sec.decks.filter(n => visible(n));
      if (!visDecks.length) return;

      anyVisible = true;
      html += `<div class="sec-head">
        <span class="sec-icon ${sec.cls}"><i class="${sec.icon}"></i></span>
        <div><div class="sec-title">${sec.label}</div></div>
        <span class="sec-count">${visDecks.length}</span>
      </div>`;

      if (sec.key === 'cabin') {
        html += `<div class="cabin-row">`;
        visDecks.forEach(n => {
          html += `<button class="cabin-chip" data-n="${n}" aria-label="Open deck ${n}">
            <span class="chip-num">${n}</span>
            <span class="chip-label">Deck ${n}</span>
          </button>`;
        });
        html += `</div>`;
      } else {
        html += `<div class="deck-grid">`;
        visDecks.forEach(n => {
          const d = byNum(n);
          const tags = (d.tags || []).slice(0,3).map(t=>`<span class="card-tag">${escapeHtml(t)}</span>`).join('');
          html += `<div class="deck-card" data-n="${n}" role="button" tabindex="0" aria-label="Open ${escapeHtml(d.sub)}">
            <div class="card-top">
              <span class="card-num">${n}</span>
              <i class="fas fa-chevron-right card-arrow"></i>
            </div>
            <div class="card-name">${escapeHtml(d.sub)}</div>
            <div class="card-tags">${tags}</div>
          </div>`;
        });
        html += `</div>`;
      }
    });

    content.innerHTML = html;
    emptyState.style.display = anyVisible ? 'none' : 'block';
  }

  /* ===========================
     SPOTS / HOTSPOTS
     =========================== */
  function renderHotspots(deck) {
    if (!deck || !deck.spots || deck.spots.length === 0) {
      hotspotsLayer.innerHTML = '';
      return;
    }
    hotspotsLayer.innerHTML = deck.spots.map((spot, idx) => {
      const label = `${spot.t}: ${spot.n || ''}`.trim();
      return `<button class="hotspot-btn" data-spot-idx="${idx}" style="left:${spot.x}%; top:${spot.y}%;" aria-label="${escapeHtml(label)}">${idx+1}</button>`;
    }).join('');
  }

  function renderLegend(deck) {
    if (!deck || !deck.spots) { legend.innerHTML = ''; return; }
    legend.innerHTML = deck.spots.map((s,i) => `
      <button class="legend-item" data-spot-idx="${i}" aria-label="Highlight ${escapeHtml(s.t)}">
        <span class="legend-n">${i+1}</span>
        <div class="legend-t"><strong>${escapeHtml(s.t)}</strong><span>${escapeHtml(s.n || '')}</span></div>
      </button>`).join('');
  }

  function highlightSpot(idx, { zoomTo = false } = {}) {
    clearSpotStates();
    const spotBtn = hotspotsLayer.querySelector(`.hotspot-btn[data-spot-idx="${idx}"]`);
    const legendItem = legend.querySelector(`.legend-item[data-spot-idx="${idx}"]`);
    if (spotBtn) spotBtn.classList.add('active');
    if (legendItem) legendItem.classList.add('active');

    if (legendItem) {
      try { legendItem.scrollIntoView({ behavior: reducedMotion ? 'auto' : 'smooth', block: 'nearest' }); } catch (_) {}
    }

    if (zoomTo && spotBtn) {
      zoomToHotspotElement(spotBtn);
    }
  }

  /* ===========================
     SMART MODE
     =========================== */
  function getSmartModeNow() {
    const h = new Date().getHours();
    if (h >= 17 && h < 22) return { key: 'dining', label: 'Dinner Mode Active' };
    if (h >= 6  && h < 10) return { key: 'breakfast', label: 'Morning Mode Active' };
    if (h >= 10 && h < 17) return { key: 'activity', label: 'Activity Mode Active' };
    return null;
  }

  function applySmartMode(deck) {
    if (!deck || !deck.spots || deck.spots.length === 0) { modalMode.textContent = ''; return; }

    const modeObj = getSmartModeNow();
    if (!modeObj) { modalMode.textContent = ''; return; }

    modalMode.textContent = modeObj.label;
    const target = (modeObj.key === 'breakfast') ? 'dining' : modeObj.key;

    deck.spots.forEach((s, i) => {
      const btn = hotspotsLayer.querySelector(`.hotspot-btn[data-spot-idx="${i}"]`);
      if (!btn) return;
      if ((s.type || '').toLowerCase() === target) {
        btn.classList.add('smart-highlight');
      } else {
        btn.classList.add('dim');
      }
    });
  }

  /* ===========================
     CINEMATIC REVEAL
     =========================== */
  function runCinematicReveal() {
    if (reducedMotion) return;
    planViewer.classList.add('light-sweep');
    window.setTimeout(() => planViewer.classList.remove('light-sweep'), 950);
    planImg.classList.add('glow');
    window.setTimeout(() => planImg.classList.remove('glow'), 650);
  }

  /* ===========================
     RAIL TICKS
     =========================== */
  function railDecks() { return ordered; }

  function clearRailTicks() {
    railTrack.querySelectorAll('.rail-tick').forEach(t => t.remove());
  }

  function renderRailTicks(activeDeckNum) {
    clearRailTicks();

    const list = railDecks();
    if (!list.length) return;

    const rect = railTrack.getBoundingClientRect();
    const yMin = 18;
    const yMax = rect.height - 18;

    list.forEach((d, i) => {
      const t = (list.length <= 1) ? 0 : i / (list.length - 1);
      const y = yMin + t * (yMax - yMin);

      const tick = document.createElement('div');
      tick.className = 'rail-tick';
      tick.style.top = `${y}px`;
      if (activeDeckNum != null && d.n === activeDeckNum) tick.classList.add('active');
      railTrack.appendChild(tick);
    });
  }

  function updateRailToDeck(deck) {
    const list = railDecks();
    const idx = list.findIndex(d => d.n === deck.n);
    if (idx < 0) return;

    const trackRect = railTrack.getBoundingClientRect();
    const yMin = 18;
    const yMax = trackRect.height - 18;
    const t = (list.length <= 1) ? 0 : idx / (list.length - 1);
    const y = yMin + t * (yMax - yMin);

    railThumb.style.top = `${y}px`;
    railThumb.textContent = String(deck.n);
    railActiveLabel.textContent = `D${deck.n}`;

    railUp.disabled = idx <= 0;
    railDown.disabled = idx >= list.length - 1;
  }

  /* ===========================
     TRANSFORM MAP ENGINE
     - momentum pan
     - boundaries
     - pinch zoom
     - double tap zoom
     - zoom-to-hotspot
     - auto-fit
     =========================== */
  const map = {
    scale: 1,
    x: 0,
    y: 0,
    minScale: 0.5,
    maxScale: 4.0,

    // Momentum
    vx: 0,
    vy: 0,
    isPanning: false,
    lastPt: null,
    raf: 0,

    // Pinch
    isPinching: false,
    pinchDist0: 0,
    pinchScale0: 1,

    // Double tap
    lastTapTs: 0,

    // Layout
    imgW: 0,
    imgH: 0,

    apply() {
      planImg.style.transform = `translate(${this.x}px, ${this.y}px) scale(${this.scale})`;
      hotspotsLayer.style.transform = `translate(${this.x}px, ${this.y}px) scale(${this.scale})`;

      // Subtle parallax on background for "depth"
      const px = Math.max(-18, Math.min(18, this.x * 0.02));
      const py = Math.max(-18, Math.min(18, this.y * 0.02));
      document.documentElement.style.setProperty('--parx', `${px}px`);
      document.documentElement.style.setProperty('--pary', `${py}px`);
    },

    setImageNaturalSize() {
      // Some SVGs may report 0 naturalWidth on certain browsers if blocked/failed.
      this.imgW = planImg.naturalWidth || planImg.width || 0;
      this.imgH = planImg.naturalHeight || planImg.height || 0;
    },

    bounds() {
      const vw = planViewer.clientWidth;
      const vh = planViewer.clientHeight;

      const iw = this.imgW * this.scale;
      const ih = this.imgH * this.scale;

      // If image smaller than viewport: keep centered
      const minX = Math.min(0, vw - iw);
      const minY = Math.min(0, vh - ih);

      return { vw, vh, iw, ih, minX, minY };
    },

    clamp() {
      const { vw, vh, iw, ih, minX, minY } = this.bounds();

      if (iw <= vw) this.x = (vw - iw) / 2;
      else this.x = Math.max(minX, Math.min(0, this.x));

      if (ih <= vh) this.y = (vh - ih) / 2;
      else this.y = Math.max(minY, Math.min(0, this.y));
    },

    snapToBounds(ms = 260) {
      // Animate from current to clamped bounds for premium "snap back"
      const startX = this.x;
      const startY = this.y;
      const startS = this.scale;

      // Compute targets via clamp on a copy
      const tx = this.x, ty = this.y, ts = this.scale;
      this.clamp();
      const targetX = this.x;
      const targetY = this.y;

      // Restore current before animating
      this.x = tx; this.y = ty; this.scale = ts;

      this.animateTo({ x: targetX, y: targetY, scale: startS }, ms);
    },

    animateTo({ x, y, scale }, ms = 260) {
      // Cancel momentum while animating
      this.stopMomentum();

      const fromX = this.x, fromY = this.y, fromS = this.scale;
      const toX = Number.isFinite(x) ? x : fromX;
      const toY = Number.isFinite(y) ? y : fromY;
      const toS = Number.isFinite(scale) ? scale : fromS;

      const t0 = performance.now();
      const ease = (t) => 1 - Math.pow(1 - t, 3); // easeOutCubic

      const tick = (now) => {
        const p = Math.min(1, (now - t0) / Math.max(1, ms));
        const k = ease(p);

        this.x = fromX + (toX - fromX) * k;
        this.y = fromY + (toY - fromY) * k;
        this.scale = fromS + (toS - fromS) * k;

        this.clamp();
        this.apply();

        if (p < 1) requestAnimationFrame(tick);
      };

      requestAnimationFrame(tick);
    },

    softPan(dx, dy) {
      // Apply rubber-band resistance when user drags beyond bounds
      const { vw, vh, iw, ih, minX, minY } = this.bounds();
      const maxX = 0;
      const maxY = 0;

      const nextX = this.x + dx;
      const nextY = this.y + dy;

      const overscroll = (v, min, max) => {
        if (v < min) return v - min;
        if (v > max) return v - max;
        return 0;
      };

      const ox = (iw <= vw) ? 0 : overscroll(nextX, minX, maxX);
      const oy = (ih <= vh) ? 0 : overscroll(nextY, minY, maxY);

      // Resistance curve (smaller movement outside bounds)
      const resist = (o) => {
        const s = Math.sign(o);
        const a = Math.min(120, Math.abs(o));
        return s * (a * 0.35);
      };

      this.x = (iw <= vw) ? (vw - iw)/2 : (nextX - resist(ox));
      this.y = (ih <= vh) ? (vh - ih)/2 : (nextY - resist(oy));
    }
},

    setScale(nextScale, centerClientX, centerClientY) {
      const clamped = Math.max(this.minScale, Math.min(this.maxScale, nextScale));
      if (this.imgW <= 0 || this.imgH <= 0) {
        this.scale = clamped;
        this.clamp();
        this.apply();
        return;
      }

      if (typeof centerClientX === 'number' && typeof centerClientY === 'number') {
        const rect = planViewer.getBoundingClientRect();
        const cx = centerClientX - rect.left;
        const cy = centerClientY - rect.top;

        // Convert viewport point to image-space point under current transform
        const ix = (cx - this.x) / this.scale;
        const iy = (cy - this.y) / this.scale;

        this.scale = clamped;
        // Keep that image-space point under the same viewport point
        this.x = cx - ix * this.scale;
        this.y = cy - iy * this.scale;
      } else {
        this.scale = clamped;
      }

      this.clamp();
      this.apply();
    },

    setZoomPercent(pct, centerClientX, centerClientY) {
      const s = Math.max(this.minScale, Math.min(this.maxScale, pct / 100));
      this.setScale(s, centerClientX, centerClientY);
      updateZoomUI();
    },

    fit() {
      this.stopMomentum();
      this.setImageNaturalSize();
      if (!isImageReady() || this.imgW <= 0 || this.imgH <= 0) return;

      const vw = planViewer.clientWidth;
      const vh = planViewer.clientHeight;

      if (this.imgW <= 0 || this.imgH <= 0 || vw <= 0 || vh <= 0) {
        // fail-safe: reset
        this.scale = 1; this.x = 0; this.y = 0;
        this.apply();
        updateZoomUI();
        return;
      }

      const fitScale = Math.min(vw / this.imgW, vh / this.imgH);
      this.scale = Math.max(this.minScale, Math.min(this.maxScale, fitScale));

      const iw = this.imgW * this.scale;
      const ih = this.imgH * this.scale;

      this.x = (vw - iw) / 2;
      this.y = (vh - ih) / 2;

      this.apply();
      updateZoomUI();
    },

    startMomentum() {
      this.stopMomentum();

      const step = () => {
        // decay tuned to feel like a map, not a hockey puck
        this.x += this.vx;
        this.y += this.vy;

        this.vx *= 0.92;
        this.vy *= 0.92;

        // clamp boundaries with a mild brake when hitting edges
        const beforeX = this.x;
        const beforeY = this.y;

        this.clamp();

        if (this.x !== beforeX) this.vx *= 0.55;
        if (this.y !== beforeY) this.vy *= 0.55;

        this.apply();

        if (Math.abs(this.vx) > 0.35 || Math.abs(this.vy) > 0.35) {
          this.raf = requestAnimationFrame(step);
        } else {
          this.raf = 0;
          // Gentle snap-back at rest
          if (!reducedMotion) this.snapToBounds(220);
        }
      };

      this.raf = requestAnimationFrame(step);
    },

    stopMomentum() {
      if (this.raf) {
        cancelAnimationFrame(this.raf);
        this.raf = 0;
      }
    }
  };

  function updateZoomUI() {
    const pct = Math.round(map.scale * 100);
    zoomRange.value = String(Math.max(50, Math.min(400, pct)));
    zoomPct.textContent = pct + '%';
  }

  function zoomToHotspotElement(btnEl) {
    if (!btnEl) return;
    if (!isImageReady()) return;

    const br = btnEl.getBoundingClientRect();
    const cxClient = br.left + br.width / 2;
    const cyClient = br.top + br.height / 2;

    const viewerRect = planViewer.getBoundingClientRect();
    const vx = cxClient - viewerRect.left;
    const vy = cyClient - viewerRect.top;

    // Convert to image-space under current transform
    const ix = (vx - map.x) / map.scale;
    const iy = (vy - map.y) / map.scale;

    const targetScale = Math.min(map.maxScale, Math.max(map.scale, 2.35));
    const vw = planViewer.clientWidth;
    const vh = planViewer.clientHeight;

    // Center hotspot in viewport at target scale
    const targetX = (vw / 2) - (ix * targetScale);
    const targetY = (vh / 2) - (iy * targetScale);

    map.animateTo({ x: targetX, y: targetY, scale: targetScale }, reducedMotion ? 0 : 280);
    updateZoomUI();
  }

  // Pinch support
  function touchDist(t1, t2) {
    return Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
  }

  function setModalGlowForDeck(deck) {
    if (!deck) return;
    const glow =
      deck.cat === 'wellness' ? '0 -20px 80px rgba(0,200,150,.25)' :
      deck.cat === 'entertainment' ? '0 -20px 80px rgba(168,85,247,.25)' :
      '0 -20px 80px rgba(0,180,230,.25)';

    const base = '0 -20px 80px rgba(0,0,0,.5)';
    modalSheet.style.boxShadow = `${base}, ${glow}`;
  }

  function currentOrderedIndex() {
    if (!currentDeck) return -1;
    return ordered.findIndex(x => x.n === currentDeck.n);
  }

  
  /* ===========================
     PRELOAD (adjacent decks)
     =========================== */
  function preloadDeckPath(path) {
    if (!path) return;
    if (preloadCache.has(path)) return;
    const img = new Image();
    img.decoding = 'async';
    img.loading = 'eager';
    preloadCache.set(path, { img, ok: false });

    img.onload = () => {
      const ent = preloadCache.get(path);
      if (ent) ent.ok = true;
    };
    img.onerror = () => {
      // keep entry to avoid retry storms
    };
    img.src = path;
  }

  function preloadAdjacent(deckNum, radius = 1) {
    const list = ordered.map(d => d.n);
    const i = list.indexOf(deckNum);
    if (i === -1) return;

    for (let r = 1; r <= radius; r++) {
      const a = list[i - r];
      const b = list[i + r];
      if (a != null) {
        const d = byNum(a);
        if (d && d.svg) preloadDeckPath(d.svg);
      }
      if (b != null) {
        const d = byNum(b);
        if (d && d.svg) preloadDeckPath(d.svg);
      }
    }
  }

function setDeck(deck, opts = {}) {
    if (!deck) return;

    const token = ++activeDeckToken;

    currentDeck = deck;
    setModalGlowForDeck(deck);

    modalTitle.textContent = deck.name + (deck.n ? ` — ${deck.sub}` : '');
    modalSub.textContent = (deck.tags || []).join(' · ');
    modalMode.textContent = '';

    const idx = ordered.findIndex(x => x.n === deck.n);
    prevBtn.disabled = idx <= 0;
    nextBtn.disabled = idx >= ordered.length - 1;

    if (deck.pdf) {
      btnPDF.dataset.pdf = deck.pdf;
      btnPDF.disabled = false;
      btnPDF.removeAttribute('aria-disabled');
    } else {
      delete btnPDF.dataset.pdf;
      btnPDF.disabled = true;
      btnPDF.setAttribute('aria-disabled','true');
    }

    chipsRow.innerHTML = (deck.chips || []).map(c => `<button class="chip" aria-label="Filter ${escapeHtml(c)}">${escapeHtml(c)}</button>`).join('');
    renderLegend(deck);

    updateRailToDeck(deck);
    requestAnimationFrame(() => renderRailTicks(deck.n));

    // Load SVG
    showShimmer();
    railThumb.classList.add('loading');
    planImg.className = 'plan-img';
    planImg.src = deck.svg || '';
    planImg.alt = deck.name;

    // Announce deck change for screen readers
    if (deckAnnounce) deckAnnounce.textContent = `${deck.name}${deck.n ? ' ' + deck.sub : ''}`;

    planImg.onload = () => {
      if (token !== activeDeckToken) return;
      if (!currentDeck || currentDeck.n !== deck.n) return;

      hideShimmer();
      railThumb.classList.remove('loading');
      planImg.classList.add('loaded');

      // Ensure hotspots and map size are synced
      renderHotspots(deck);
      clearSpotStates();

      // Fit + center after load (animated)
      map.setImageNaturalSize();
      if (!reducedMotion) {
        map.fit();
        map.snapToBounds(260);
      } else {
        map.fit();
      }

      applySmartMode(deck);
      runCinematicReveal();
      preloadAdjacent(deck.n, 2);
      maybeShowGestureHint();

      showToast(`Loaded Deck ${deck.n || ''}`.trim());
    };

    planImg.onerror = () => {
      if (token !== activeDeckToken) return;
      if (!currentDeck || currentDeck.n !== deck.n) return;
      hideShimmer();
      railThumb.classList.remove('loading');
      renderHotspots(deck);
      clearSpotStates();
      modalMode.textContent = '';
      showToast('Deck image failed to load (check path)');
    };
  }

  function openModal(deck) {
    lastFocusedBeforeModal = document.activeElement;
    setDeck(deck, { firstOpen: true });
    modal.classList.add('open');
    document.body.style.overflow = 'hidden';
    safeFocus($('modalClose'));
  }

  function closeModal() {
    modal.classList.remove('open');
    document.body.style.overflow = '';
    clearSpotStates();
    map.stopMomentum();

    if (lastFocusedBeforeModal && typeof lastFocusedBeforeModal.focus === 'function') {
      try { lastFocusedBeforeModal.focus(); } catch (_) {}
    }
    lastFocusedBeforeModal = null;
  }

  /* ===========================
     RAIL DRAG
     =========================== */
  let railDragging = false;
  let railRaf = 0;
  let lastRailIdx = -1;

  function idxFromClientY(clientY) {
    const list = railDecks();
    const rect = railTrack.getBoundingClientRect();
    const y = Math.min(rect.bottom, Math.max(rect.top, clientY)) - rect.top;

    const yMin = 18;
    const yMax = rect.height - 18;
    const clamped = Math.min(yMax, Math.max(yMin, y));

    const t = (yMax - yMin) <= 0 ? 0 : (clamped - yMin) / (yMax - yMin);
    const idx = Math.round(t * (list.length - 1));
    return Math.min(list.length - 1, Math.max(0, idx));
  }

  function setDeckByRailIndex(idx) {
    const list = railDecks();
    if (idx < 0 || idx >= list.length) return;

    const next = list[idx];
    if (!currentDeck || next.n === currentDeck.n) return;

    setDeck(next);
    try { if (navigator.vibrate) navigator.vibrate(8); } catch (_) {}
  }

  function railPointerDown(e) {
    if (!modal.classList.contains('open')) return;
    railDragging = true;
    railThumb.classList.add('dragging');
    lastRailIdx = -1;

    if (railTrack.setPointerCapture && e.pointerId != null) {
      try { railTrack.setPointerCapture(e.pointerId); } catch (_) {}
    }
    railPointerMove(e);
  }

  function railPointerMove(e) {
    if (!railDragging) return;

    const clientY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
    if (clientY == null) return;

    const rect = railTrack.getBoundingClientRect();
    const yRaw = Math.min(rect.bottom, Math.max(rect.top, clientY)) - rect.top;

    const yMin = 18;
    const yMax = rect.height - 18;
    const y = Math.min(yMax, Math.max(yMin, yRaw));

    railThumb.style.top = `${y}px`;

    if (!railRaf) {
      railRaf = requestAnimationFrame(() => {
        railRaf = 0;
        const idx = idxFromClientY(clientY);

        if (lastRailIdx === -1) {
          lastRailIdx = idx;
          setDeckByRailIndex(idx);
          return;
        }
        if (idx !== lastRailIdx) {
          lastRailIdx = idx;
          setDeckByRailIndex(idx);
        }
      });
    }
  }

  function railPointerUp() {
    railDragging = false;
    railThumb.classList.remove('dragging');
    lastRailIdx = -1;
    if (currentDeck) updateRailToDeck(currentDeck);
  }

  /* ===========================
     EVENTS
     =========================== */
  $('filters').addEventListener('click', (e) => {
    const b = e.target.closest('.f-btn');
    if (!b) return;

    document.querySelectorAll('.f-btn').forEach(x => { x.classList.remove('active'); x.setAttribute('aria-pressed', 'false'); });
    b.classList.add('active');
    b.setAttribute('aria-pressed', 'true');

    filt = b.dataset.f || 'all';
    render();
  });

  $('deckSearch').addEventListener('input', (e) => { query = e.target.value || ''; render(); });

  content.addEventListener('click', (e) => {
    const card = e.target.closest('[data-n]');
    if (!card) return;
    const d = byNum(Number(card.dataset.n));
    if (d) openModal(d);
  });

  content.addEventListener('keydown', (e) => {
    if (e.key !== 'Enter' && e.key !== ' ') return;
    const card = e.target.closest('[data-n]');
    if (!card) return;
    e.preventDefault();
    const d = byNum(Number(card.dataset.n));
    if (d) openModal(d);
  });

  backdrop.addEventListener('click', closeModal);
  $('modalClose').addEventListener('click', closeModal);
  $('btnClose2').addEventListener('click', closeModal);

  document.addEventListener('keydown', (e) => {
    if (!modal.classList.contains('open')) return;
    if (e.key === 'Escape') closeModal();
    if (e.key === 'ArrowLeft') prevBtn.click();
    if (e.key === 'ArrowRight') nextBtn.click();
  });

  prevBtn.addEventListener('click', () => {
    const idx = currentOrderedIndex();
    if (idx <= 0) return;
    setDeck(ordered[idx - 1]);
  });
  nextBtn.addEventListener('click', () => {
    const idx = currentOrderedIndex();
    if (idx < 0 || idx >= ordered.length - 1) return;
    setDeck(ordered[idx + 1]);
  });

  zoomInBtn.addEventListener('click', () => map.setZoomPercent((map.scale * 100) + 25));
  zoomOutBtn.addEventListener('click', () => map.setZoomPercent((map.scale * 100) - 25));
  zoomFit.addEventListener('click', () => { map.fit(); map.snapToBounds(reducedMotion ? 0 : 220); });

  zoomRange.addEventListener('input', (e) => {
    const v = Number(e.target.value || 100);
    map.setZoomPercent(v);
    map.snapToBounds(reducedMotion ? 0 : 180);
  });

  chipsRow.addEventListener('click', (e) => {
    const chip = e.target.closest('.chip');
    if (!chip || !currentDeck || !currentDeck.spots) return;
    const text = chip.textContent.trim().toLowerCase();
    const idx = currentDeck.spots.findIndex(s => (s.t || '').toLowerCase().includes(text));
    if (idx !== -1) highlightSpot(idx, { zoomTo: true });
  });

  legend.addEventListener('click', (e) => {
    const item = e.target.closest('.legend-item');
    if (!item) return;
    const idx = Number(item.dataset.spotIdx);
    if (!Number.isNaN(idx)) highlightSpot(idx, { zoomTo: true });
  });

  hotspotsLayer.addEventListener('click', (e) => {
    const btn = e.target.closest('.hotspot-btn');
    if (!btn) return;
    const idx = Number(btn.dataset.spotIdx);
    if (!Number.isNaN(idx)) highlightSpot(idx, { zoomTo: true });
  });

  btnLoc.addEventListener('click', () => showToast('My Location: coming soon'));

  function openDrawer() {
    drawerBackdrop.classList.add('open');
    drawerBackdrop.setAttribute('aria-hidden', 'false');
    document.body.style.overflow = 'hidden';
    safeFocus(closeDrawerBtn);
  }
  function closeDrawer() {
    drawerBackdrop.classList.remove('open');
    drawerBackdrop.setAttribute('aria-hidden', 'true');
    document.body.style.overflow = '';
    safeFocus(menuBtn);
  }
  menuBtn.addEventListener('click', openDrawer);
  closeDrawerBtn.addEventListener('click', closeDrawer);
  drawerBackdrop.addEventListener('click', (e) => { if (e.target === drawerBackdrop) closeDrawer(); });

  window.addEventListener('scroll', () => backToTop.classList.toggle('show', window.scrollY > 400));
  backToTop.addEventListener('click', () => window.scrollTo({ top: 0, behavior: reducedMotion ? 'auto' : 'smooth' }));

  /* Rail events */
  railTrack.addEventListener('pointerdown', railPointerDown);
  railTrack.addEventListener('pointermove', railPointerMove);
  railTrack.addEventListener('pointerup', railPointerUp);
  railTrack.addEventListener('pointercancel', railPointerUp);

  railTrack.addEventListener('touchstart', (e) => {
    railDragging = true;
    railThumb.classList.add('dragging');
    lastRailIdx = -1;
    railPointerMove(e);
    e.preventDefault();
  }, { passive: false });
  railTrack.addEventListener('touchmove', (e) => { railPointerMove(e); e.preventDefault(); }, { passive: false });
  railTrack.addEventListener('touchend', () => railPointerUp(), { passive: true });

  railUp.addEventListener('click', () => {
    if (!currentDeck) return;
    const idx = railDecks().findIndex(d => d.n === currentDeck.n);
    setDeckByRailIndex(Math.max(0, idx - 1));
  });
  railDown.addEventListener('click', () => {
    if (!currentDeck) return;
    const idx = railDecks().findIndex(d => d.n === currentDeck.n);
    setDeckByRailIndex(Math.min(railDecks().length - 1, idx + 1));
  });

  window.addEventListener('resize', () => {
    if (!modal.classList.contains('open') || !currentDeck) return;
    window.clearTimeout(resizeTimer);
    resizeTimer = window.setTimeout(() => {
      if (!modal.classList.contains('open') || !currentDeck) return;
      updateRailToDeck(currentDeck);
      renderRailTicks(currentDeck.n);
      if (isImageReady()) map.fit();
    }, 120);
  });

  /* ===========================
     MAP ENGINE INPUT
     =========================== */
  // Pointer pan with momentum
  planViewer.addEventListener('pointerdown', (e) => {
    if (!modal.classList.contains('open')) return;
    // Ignore pan if user is dragging rail
    if (railDragging) return;

    map.stopMomentum();
    map.isPanning = true;
    map.lastPt = { x: e.clientX, y: e.clientY };
    map.vx = 0; map.vy = 0;

    try { planViewer.setPointerCapture(e.pointerId); } catch (_) {}
  });

  planViewer.addEventListener('pointermove', (e) => {
    if (!map.isPanning) return;

    const dx = e.clientX - map.lastPt.x;
    const dy = e.clientY - map.lastPt.y;

    map.softPan(dx, dy);

    map.vx = dx;
    map.vy = dy;

    map.lastPt = { x: e.clientX, y: e.clientY };

    map.apply();
  });

  planViewer.addEventListener('pointerup', () => {
    if (!map.isPanning) return;
    map.isPanning = false;
    map.startMomentum();
    // Premium snap-back (after user lets go)
    map.snapToBounds(reducedMotion ? 0 : 220);
  });
  planViewer.addEventListener('pointercancel', () => {
    map.isPanning = false;
    map.stopMomentum();
  });

  // iOS pinch zoom
  planViewer.addEventListener('touchstart', (e) => {
    if (!modal.classList.contains('open')) return;

    if (e.touches.length === 1) {
      const t0 = e.touches[0];
      tapStart = { x: t0.clientX, y: t0.clientY, t: Date.now() };
      tapMoved = false;
    }

    if (e.touches.length === 2) {
      map.isPinching = true;
      map.stopMomentum();
      map.pinchDist0 = touchDist(e.touches[0], e.touches[1]);
      map.pinchScale0 = map.scale;
      e.preventDefault();
      return;
    }
  }, { passive: false });

  planViewer.addEventListener('touchmove', (e) => {
    if (tapStart && e.touches.length === 1) {
      const t1 = e.touches[0];
      const dx = t1.clientX - tapStart.x;
      const dy = t1.clientY - tapStart.y;
      if ((dx*dx + dy*dy) > (TAP_MAX_MOVE_PX*TAP_MAX_MOVE_PX)) tapMoved = true;
    }

    if (!map.isPinching) return;
    if (e.touches.length !== 2) return;

    const d = touchDist(e.touches[0], e.touches[1]);
    const factor = d / Math.max(10, map.pinchDist0);

    const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

    map.setScale(map.pinchScale0 * factor, centerX, centerY);
    updateZoomUI();
    e.preventDefault();
  }, { passive: false });

  planViewer.addEventListener('touchend', (e) => {
    if (e.touches.length < 2) map.isPinching = false;
  }, { passive: true });

  // Double tap zoom (100% ⇄ 200%) anchored to tap point
  planViewer.addEventListener('touchend', (e) => {
    if (!modal.classList.contains('open')) return;
    if (map.isPinching) return;

    const now = Date.now();
    const touch = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : null;
    if (!touch) return;

    const elapsed = tapStart ? (now - tapStart.t) : 9999;
    const isTapLike = !!tapStart && !tapMoved && elapsed <= TAP_MAX_MS;

    if (!isTapLike) {
      map.lastTapTs = 0;
      tapStart = null;
      tapMoved = false;
      return;
    }

    if (now - map.lastTapTs < 280) {
      map.stopMomentum();
      const targetPct = (Math.round(map.scale * 100) <= 110) ? 200 : 100;
      map.setZoomPercent(targetPct, touch.clientX, touch.clientY);
      map.lastTapTs = 0;
      // snap back if needed
      map.snapToBounds(reducedMotion ? 0 : 220);
    } else {
      map.lastTapTs = now;
    }

    tapStart = null;
    tapMoved = false;
  }, { passive: true });

  /* ===========================
     OCEAN BACKGROUND
     =========================== */
  const oceanCanvas = $('ocean');
  if (oceanCanvas) {
    const ctx = oceanCanvas.getContext('2d', { alpha: true });
    const waves = [
      { amp: 22, len: 0.010, speed: 0.010, y: 0.46, alpha: 0.11 },
      { amp: 30, len: 0.008, speed: 0.013, y: 0.54, alpha: 0.09 },
      { amp: 38, len: 0.006, speed: 0.016, y: 0.62, alpha: 0.07 },
    ];
    let t = 0;
    let raf = 0;

    function resize() {
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      oceanCanvas.width = Math.floor(window.innerWidth * dpr);
      oceanCanvas.height = Math.floor(window.innerHeight * dpr);
      oceanCanvas.style.width = window.innerWidth + 'px';
      oceanCanvas.style.height = window.innerHeight + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resize();
    window.addEventListener('resize', resize);

    function frame() {
      const w = window.innerWidth;
      const h = window.innerHeight;

      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = '#071a2c';
      ctx.fillRect(0, 0, w, h);

      waves.forEach((wa, i) => {
        const baseY = h * wa.y;
        ctx.beginPath();
        ctx.moveTo(0, baseY);
        for (let x = 0; x <= w; x += 8) {
          ctx.lineTo(x, baseY + Math.sin(x * wa.len + t * (0.8 + i * 0.15)) * wa.amp);
        }
        ctx.lineTo(w, h);
        ctx.lineTo(0, h);
        ctx.closePath();
        ctx.fillStyle = `rgba(0,180,230,${wa.alpha})`;
        ctx.fill();
      });

      t += reducedMotion ? 0.004 : 0.012;
      raf = requestAnimationFrame(frame);
    }

    function startOcean() {
      if (raf) return;
      raf = requestAnimationFrame(frame);
    }

    function stopOcean() {
      if (!raf) return;
      cancelAnimationFrame(raf);
      raf = 0;
    }

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) stopOcean();
      else startOcean();
    });

    startOcean();
  }

  /* ===========================
     INIT
     =========================== */
  render();

})();
</script>

  <script src="js/global.js" defer></script>
  <script src="js/shared-layout.js" defer></script>
  <script src="js/decks.js" defer></script>
</body></html>